<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown代码样式测试文件</title>
      <link href="/2025/04/26/demo/"/>
      <url>/2025/04/26/demo/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown代码样式测试文件"><a href="#Markdown代码样式测试文件" class="headerlink" title="Markdown代码样式测试文件"></a>Markdown代码样式测试文件</h1><p>这是一个用于测试Markdown代码格式和样式的文件，包含了多种代码块和格式化内容。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E6%B5%8B%E8%AF%95">代码块测试</a></li><li><a href="#%E8%A1%A8%E6%A0%BC%E6%B5%8B%E8%AF%95">表格测试</a></li><li><a href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95">数学公式测试</a></li><li><a href="#%E5%88%97%E8%A1%A8%E6%B5%8B%E8%AF%95">列表测试</a></li><li><a href="#%E5%BC%95%E7%94%A8%E6%B5%8B%E8%AF%95">引用测试</a></li></ul><h2 id="代码块测试"><a href="#代码块测试" class="headerlink" title="代码块测试"></a>代码块测试</h2><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><p>这是一个没有指定语言的代码块：</p><pre><code>function normalCode() &#123;  console.log(&quot;这是一个普通代码块&quot;);&#125;</code></pre><h3 id="Python代码块"><a href="#Python代码块" class="headerlink" title="Python代码块"></a>Python代码块</h3><pre class="line-numbers language-language-python"><code class="language-language-python">def hello_world():    print("Hello, World!")    # 一个简单的类定义class Person:    def __init__(self, name, age):        self.name = name        self.age = age            def greet(self):        return f"你好，我是&#123;self.name&#125;，今年&#123;self.age&#125;岁"        # 使用类p = Person("张三", 25)print(p.greet())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JavaScript代码块"><a href="#JavaScript代码块" class="headerlink" title="JavaScript代码块"></a>JavaScript代码块</h3><pre class="line-numbers language-language-javascript"><code class="language-language-javascript">// 箭头函数const add = (a, b) => a + b;// 使用模板字符串function greet(name) &#123;  return `Hello, $&#123;name&#125;!`;&#125;// Promise示例function fetchData() &#123;  return new Promise((resolve, reject) => &#123;    setTimeout(() => &#123;      resolve(&#123; data: "这是一些数据" &#125;);    &#125;, 1000);  &#125;);&#125;// 异步函数async function getData() &#123;  try &#123;    const result = await fetchData();    console.log(result.data);  &#125; catch (error) &#123;    console.error("发生错误:", error);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bash-Shell代码块"><a href="#Bash-Shell代码块" class="headerlink" title="Bash&#x2F;Shell代码块"></a>Bash&#x2F;Shell代码块</h3><pre class="line-numbers language-language-bash"><code class="language-language-bash">#!/bin/bash# 这是一个简单的shell脚本echo "当前目录是:"pwd# 循环示例for i in &#123;1..5&#125;; do  echo "第 $i 次迭代"done# 条件判断if [ -f "config.yml" ]; then  echo "配置文件存在"else  echo "配置文件不存在"fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Java代码块"><a href="#Java代码块" class="headerlink" title="Java代码块"></a>Java代码块</h3><pre class="line-numbers language-language-java"><code class="language-language-java">public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println("Hello, World!");                // 创建一个对象        Person person = new Person("李四", 30);        System.out.println(person.greet());    &#125;&#125;class Person &#123;    private String name;    private int age;        public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public String greet() &#123;        return "你好，我是" + name + "，今年" + age + "岁";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="包含管道符的代码块（测试特殊字符）"><a href="#包含管道符的代码块（测试特殊字符）" class="headerlink" title="包含管道符的代码块（测试特殊字符）"></a>包含管道符的代码块（测试特殊字符）</h3><p>下面的代码块包含了管道符 <code>|</code>，这可能会被误解为表格分隔符：</p><pre class="line-numbers language-language-text"><code class="language-language-text"># 这行包含管道符echo "A" | grep "A"# 数据示例名称 | 年龄 | 职业小明 | 25 | 工程师小红 | 24 | 设计师<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格测试"><a href="#表格测试" class="headerlink" title="表格测试"></a>表格测试</h2><p>这是一个标准的 Markdown 表格：</p><table><thead><tr><th>名称</th><th>年龄</th><th>职业</th></tr></thead><tbody><tr><td>小明</td><td>25</td><td>工程师</td></tr><tr><td>小红</td><td>24</td><td>设计师</td></tr><tr><td>小李</td><td>26</td><td>医生</td></tr></tbody></table><p>左对齐、居中和右对齐的混合表格：</p><table><thead><tr><th align="left">名称 (左对齐)</th><th align="center">年龄 (居中)</th><th align="right">薪资 (右对齐)</th></tr></thead><tbody><tr><td align="left">张三</td><td align="center">25</td><td align="right">¥10,000</td></tr><tr><td align="left">李四</td><td align="center">26</td><td align="right">¥12,000</td></tr><tr><td align="left">王五</td><td align="center">24</td><td align="right">¥9,500</td></tr></tbody></table><h2 id="数学公式测试"><a href="#数学公式测试" class="headerlink" title="数学公式测试"></a>数学公式测试</h2><p>这里是一些数学公式测试（使用 LaTeX 语法）：</p><p>行内公式: $E &#x3D; mc^2$</p><p>独立公式:</p><p>$$<br>\frac{d}{dx}e^x &#x3D; e^x<br>$$</p><p>复杂公式:</p><p>$$<br>\begin{align}<br>\nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; &#x3D; \frac{4\pi}{c}\vec{\mathbf{j}} \<br>\nabla \cdot \vec{\mathbf{E}} &amp; &#x3D; 4 \pi \rho \<br>\nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; &#x3D; \vec{\mathbf{0}} \<br>\nabla \cdot \vec{\mathbf{B}} &amp; &#x3D; 0<br>\end{align}<br>$$</p><p>余弦相似度计算公式:</p><p>$$<br>similarity(A,B) &#x3D; \frac{A \cdot B}{||A|| \cdot ||B||}<br>$$</p><p>欧氏距离计算公式:</p><p>$$<br>distance(A,B) &#x3D; \sqrt{\sum_{i&#x3D;1}^{n}(A_i-B_i)^2}<br>$$</p><h2 id="列表测试"><a href="#列表测试" class="headerlink" title="列表测试"></a>列表测试</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>第一项</li><li>第二项</li><li>第三项<ul><li>子项 1</li><li>子项 2<ul><li>子子项 1</li><li>子子项 2</li></ul></li></ul></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>第一步</li><li>第二步</li><li>第三步<ol><li>子步骤 1</li><li>子步骤 2<ol><li>详细步骤 a</li><li>详细步骤 b</li></ol></li></ol></li></ol><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul><li><input checked disabled type="checkbox"> 已完成任务</li><li><input disabled type="checkbox"> 未完成任务</li><li><input disabled type="checkbox"> 另一个未完成任务<ul><li><input checked disabled type="checkbox"> 已完成子任务</li><li><input disabled type="checkbox"> 未完成子任务</li></ul></li></ul><h2 id="引用测试"><a href="#引用测试" class="headerlink" title="引用测试"></a>引用测试</h2><blockquote><p>这是一个简单的引用</p></blockquote><p>多层嵌套引用:</p><blockquote><p>第一层引用</p><blockquote><p>第二层引用</p><blockquote><p>第三层引用</p><p>继续第三层</p></blockquote></blockquote></blockquote><p>带有其他元素的引用:</p><blockquote><h4 id="引用中的标题"><a href="#引用中的标题" class="headerlink" title="引用中的标题"></a>引用中的标题</h4><ul><li>引用中的列表项</li><li>另一个列表项</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python"># 引用中的代码块print("Hello from a quote!")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h2 id="图片和链接测试"><a href="#图片和链接测试" class="headerlink" title="图片和链接测试"></a>图片和链接测试</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.markdownguide.org/">Markdown语法指南</a></p><p><a href="https://hexo.io/">Hexo官方网站</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="https://via.placeholder.com/600x400" alt="示例图片" title="这是一个占位图片"></p><h2 id="高级格式测试"><a href="#高级格式测试" class="headerlink" title="高级格式测试"></a>高级格式测试</h2><h3 id="高亮文本"><a href="#高亮文本" class="headerlink" title="高亮文本"></a>高亮文本</h3><p>使用 <code>&lt;mark&gt;</code> 标签可以 <mark>高亮显示文本</mark>。</p><h3 id="删除线和下划线"><a href="#删除线和下划线" class="headerlink" title="删除线和下划线"></a>删除线和下划线</h3><p><del>这是删除线文本</del> 和 <u>这是下划线文本</u>。</p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>这是一个带有脚注的文本<a href="%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A8%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82">^1</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个Markdown文档包含了多种常见的代码块和格式化元素，可以用来测试您的Hexo主题是否正确渲染这些元素。如果所有内容都能正确显示，那么您的配置应该是正确的。</p><p>如果出现问题，特别注意:</p><ol><li>代码块中的语言标记是否正确</li><li>包含特殊字符的代码块是否正确渲染</li><li>数学公式是否正确显示</li><li>表格是否对齐且正确显示</li></ol>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kakfa 整理</title>
      <link href="/2025/02/26/kafka-bi-ji/"/>
      <url>/2025/02/26/kafka-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>📌 引言</p><p>在使用 Kafka 进行消息消费时，Offset 机制是一个核心概念。Offset 决定了消费者从哪里读取数据，并影响消费的可靠性与一致性。本篇文章将深入剖析 Kafka Offset 的工作原理，以及 <code>auto.offset.reset</code> 在不同场景下的行为。</p><h2 id="Kafka-Offset-机制概述"><a href="#Kafka-Offset-机制概述" class="headerlink" title="Kafka Offset 机制概述"></a>Kafka Offset 机制概述</h2><p>Kafka 采用 Offset（偏移量）来跟踪消费者的消费进度。Offset 是消息在 Kafka 分区中的唯一编号，类似数据库中的自增 ID。</p><ul><li><strong>Start Offset</strong>（日志起始 Offset）：该分区最早可用的消息 Offset（受 Kafka 日志保留策略影响）。</li><li><strong>End Offset</strong>（日志结束 Offset）：该分区最新消息的 Offset。</li><li><strong>Committed Offset</strong>（已提交 Offset）：消费者组提交的最新 Offset，表示该消费者已成功消费的数据。</li><li><strong>Current Offset</strong>（当前 Offset）：消费者<strong>正在消费</strong>的消息 Offset。</li></ul><p>Kafka 允许消费者手动或自动提交 Offset，并提供 <code>auto.offset.reset</code> 选项来决定在找不到 Offset 时的行为。</p><hr><h3 id="auto-offset-reset-详解"><a href="#auto-offset-reset-详解" class="headerlink" title="auto.offset.reset 详解"></a>auto.offset.reset 详解</h3><h4 id="🔹-什么是-auto-offset-reset"><a href="#🔹-什么是-auto-offset-reset" class="headerlink" title="🔹 什么是 auto.offset.reset"></a>🔹 什么是 auto.offset.reset</h4><p><code>auto.offset.reset</code> 决定了消费者在 Kafka <strong>找不到已提交的 Offset</strong> 时应该如何处理。</p><ul><li><code>earliest</code>：从 <strong>Start Offset</strong>（最早可用消息）开始消费。</li><li><code>latest</code>：从 <strong>End Offset</strong>（最新写入的消息）开始消费。</li><li><code>none</code>：如果找不到 Offset，则抛出异常。</li></ul><h4 id="🔹-什么时候-Kafka-会“找不到-Offset”"><a href="#🔹-什么时候-Kafka-会“找不到-Offset”" class="headerlink" title="🔹 什么时候 Kafka 会“找不到 Offset”"></a>🔹 什么时候 Kafka 会“找不到 Offset”</h4><p>Kafka 找不到 Offset 主要发生在以下几种场景：</p><table><thead><tr><th>场景</th><th>发生原因</th><th>影响</th></tr></thead><tbody><tr><td><strong>新消费者组</strong></td><td><code>group.id</code> 从未消费过该主题，没有 Offset 记录</td><td>按 <code>auto.offset.reset</code> 规则消费</td></tr><tr><td><strong>Offset 过期</strong></td><td>超过 <code>offsets.retention.minutes</code>（默认 7 天），Kafka 自动清理 Offset</td><td>按 <code>auto.offset.reset</code> 规则消费</td></tr><tr><td><strong>主题被删除&#x2F;重建</strong></td><td>主题被删除后重新创建，原 Offset 记录丢失</td><td>按 <code>auto.offset.reset</code> 规则消费</td></tr><tr><td><strong>分区调整</strong></td><td>Kafka 重新分配分区，导致 Offset 失效</td><td>按 <code>auto.offset.reset</code> 规则消费</td></tr></tbody></table><h3 id="enable-auto-commit-false-时，Offset-何时更新？"><a href="#enable-auto-commit-false-时，Offset-何时更新？" class="headerlink" title="enable.auto.commit&#x3D;false 时，Offset 何时更新？"></a>enable.auto.commit&#x3D;false 时，Offset 何时更新？</h3><p>当 <code>enable.auto.commit=false</code> 时，Kafka <strong>不会自动提交 Offset</strong>，消费者需要手动调用 <code>consumer.commit()</code> 进行提交。</p><p><strong>如果不手动 <code>commit()</code>，Offset 会发生什么？</strong></p><ul><li><strong>Kafka 不会更新 Offset</strong>，下次重启消费者时会从旧的 Offset 重新消费（可能会重复消费）。</li><li><strong>Offset 只会在 <code>commit()</code> 之后更新</strong>，否则 Kafka 认为这条消息还未消费完成。</li></ul><p><strong>示例代码</strong>：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from confluent_kafka import Consumerconsumer = Consumer(&#123;    'bootstrap.servers': 'localhost:9092',    'group.id': 'my-group',    'auto.offset.reset': 'earliest',    'enable.auto.commit': False&#125;)consumer.subscribe(['my-topic'])while True:    msg = consumer.poll(1.0)    if msg is None:        continue    print(f"Received message: &#123;msg.value().decode('utf-8')&#125;")    consumer.commit()  # 手动提交 Offset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="max-poll-interval-ms和消费者会话管理"><a href="#max-poll-interval-ms和消费者会话管理" class="headerlink" title="max.poll.interval.ms和消费者会话管理"></a>max.poll.interval.ms和消费者会话管理</h3><p>Kafka 通过 <code>max.poll.interval.ms</code> 控制消费者的活跃性。</p><h4 id="🔹-max-poll-interval-ms机制"><a href="#🔹-max-poll-interval-ms机制" class="headerlink" title="🔹 max.poll.interval.ms机制"></a>🔹 max.poll.interval.ms机制</h4><ul><li><strong>作用</strong>：如果 <code>poll()</code> 调用间隔超过 <code>max.poll.interval.ms</code>，Kafka 认为该消费者已失效，会触发 Rebalance。</li><li><strong>默认值</strong>：<code>300000ms</code>（5分钟）。</li><li><strong>影响</strong>：如果消费逻辑太慢，或者 <code>poll()</code> 迟迟未被调用，消费者会被踢出消费组，导致分区重新分配。</li></ul><h4 id="🔹-session-timeout-ms-机制"><a href="#🔹-session-timeout-ms-机制" class="headerlink" title="**🔹 session.timeout.ms 机制"></a>**🔹 session.timeout.ms 机制</h4><ul><li><strong>作用</strong>：如果消费者在 <code>session.timeout.ms</code> 内没有向 Kafka 发送心跳，Kafka 认为它已失联，触发 Rebalance。</li><li><strong>默认值</strong>：<code>45000ms</code>（45秒）。</li><li><strong>影响</strong>：如果消费者进程崩溃或网络问题，Kafka 会快速 Rebalance。</li></ul><p><strong>示例代码：避免因 <code>poll()</code> 过慢被踢出消费组</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">consumer = Consumer(&#123;    'bootstrap.servers': 'localhost:9092',    'group.id': 'my-group',    'auto.offset.reset': 'earliest',    'enable.auto.commit': False,    'max.poll.interval.ms': 600000  # 10分钟&#125;)while True:    msg = consumer.poll(1.0)    if msg is None:        continue  # 即使没有新消息，也要继续 poll()，否则可能被踢出    print(f"Received: &#123;msg.value().decode('utf-8')&#125;")    consumer.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="避免-Kafka-Offset-丢失的最佳实践"><a href="#避免-Kafka-Offset-丢失的最佳实践" class="headerlink" title="避免 Kafka Offset 丢失的最佳实践"></a>避免 Kafka Offset 丢失的最佳实践</h3><p>为了保证 Kafka Offset 不会丢失，避免 <code>auto.offset.reset</code> 触发意外行为，可以采用以下策略：</p><h4 id="✅-定期提交-Offset"><a href="#✅-定期提交-Offset" class="headerlink" title="✅ 定期提交 Offset"></a>✅ 定期提交 Offset</h4><ul><li>关闭 <code>enable.auto.commit</code>，并手动 <code>commit()</code>。</li><li>例如，每 100 条消息提交一次 Offset。</li></ul><h4 id="✅-避免长时间不消费"><a href="#✅-避免长时间不消费" class="headerlink" title="✅ 避免长时间不消费"></a>✅ 避免长时间不消费</h4><ul><li>定期启动消费者，避免超过 <code>offsets.retention.minutes</code>（默认 7 天）。</li></ul><h4 id="✅-使用-kafka-consumer-groups-sh-监控-Offset"><a href="#✅-使用-kafka-consumer-groups-sh-监控-Offset" class="headerlink" title="✅ 使用 kafka-consumer-groups.sh 监控 Offset"></a>✅ 使用 kafka-consumer-groups.sh 监控 Offset</h4><pre><code>kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group my-group --describe</code></pre><h4 id="✅-设置合理的-max-poll-interval-ms-和-session-timeout-ms"><a href="#✅-设置合理的-max-poll-interval-ms-和-session-timeout-ms" class="headerlink" title="✅ 设置合理的 max.poll.interval.ms 和 session.timeout.ms"></a>✅ 设置合理的 max.poll.interval.ms 和 session.timeout.ms</h4><ul><li>确保消费者不会因消费太慢被踢出消费组。</li></ul><h3 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a>📌 总结</h3><ul><li><strong>Kafka 只有在找不到 Offset 时，才会根据 <code>auto.offset.reset</code> 规则决定从哪里消费。</strong></li><li><strong><code>enable.auto.commit=false</code> 时，Offset 需要手动 <code>commit()</code>，否则不会前进。</strong></li><li><strong><code>max.poll.interval.ms</code> 影响消费者的存活，过长的处理时间可能导致消费者被踢出消费组。</strong></li><li><strong>避免 Offset 丢失的方法包括：定期提交 Offset、避免长时间不消费、监控 Offset 变化。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大模型 RAG 应用开发基础及入门</title>
      <link href="/2025/02/12/da-mo-xing-rag-ying-yong-kai-fa-ji-chu-ji-ru-men/"/>
      <url>/2025/02/12/da-mo-xing-rag-ying-yong-kai-fa-ji-chu-ji-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是大语言模型的幻觉？"><a href="#什么是大语言模型的幻觉？" class="headerlink" title="什么是大语言模型的幻觉？"></a>什么是大语言模型的幻觉？</h2><p>大语言模型在处理自然语言时，有时候会出现”幻觉“现象。所谓幻觉，就是模型生成的内容与事实或上下文不一致的问题。这些问题会严重影响AI应用的可靠性和实用性。</p><h2 id="幻觉的两大类型"><a href="#幻觉的两大类型" class="headerlink" title="幻觉的两大类型"></a>幻觉的两大类型</h2><h3 id="事实性幻觉"><a href="#事实性幻觉" class="headerlink" title="事实性幻觉"></a>事实性幻觉</h3><p>指模型生成的内容与实际事实不匹配。比如在回答”第一个登上月球的人是谁?”这个问题时:</p><ul><li>错误回答: “Charles Lindbergh在1951年月球任务中第一个登上月球”</li><li>正确事实: Neil Armstrong才是第一个登上月球的人(1969年阿波罗11号任务)</li></ul><p>这种幻觉之所以危险，是因为模型生成的内容看起来很可信，但实际上完全错误。</p><h3 id="忠实性幻觉"><a href="#忠实性幻觉" class="headerlink" title="忠实性幻觉"></a>忠实性幻觉</h3><p>指模型生成的内容与提供的上下文不一致。这种幻觉可以分为三类：</p><ul><li>输出与原文不一致（编出原文中没有的信息）</li><li>上下文之间不一致（前后矛盾）</li><li>逻辑链不一致（推理过程存在漏洞）</li></ul><p>比如在总结新闻时，模型可能会添加原文中不存在的细节，或者前后描述矛盾。</p><h2 id="为什么会产生幻觉？"><a href="#为什么会产生幻觉？" class="headerlink" title="为什么会产生幻觉？"></a>为什么会产生幻觉？</h2><p>大语言模型产生幻觉的原因主要来自三个方面：</p><ol><li>数据源导致的幻觉<ul><li>训练数据中的质量问题</li><li>数据中存在的错误信息</li><li>数据覆盖范围有限</li></ul></li><li>训练过程导致的幻觉<ul><li>架构限制：无法准确理解长文本的上下文关联</li><li>累积错误：生成过程中的错误会逐步传递和放大</li></ul></li><li>推理相关的幻觉<ul><li>回答过于简略</li><li>生成过程中的不完整推理</li></ul></li></ol><h2 id="如何评估幻觉问题"><a href="#如何评估幻觉问题" class="headerlink" title="如何评估幻觉问题"></a>如何评估幻觉问题</h2><p>为了客观评估模型的幻觉问题，我们可以使用多种方法：</p><ol><li>事实一致性评估：将生成内容与权威来源进行比对</li><li>分类器评估：使用专门训练的模型来检测是否存在幻觉</li><li>问答测量：通过问答来验证生成内容的一致性</li><li>不确定度分析：评估模型对自身输出的确信程度</li><li>提示测量：让模型自我评估，通过特定提示策略来评估生成内容</li></ol><h2 id="RAG解决方案"><a href="#RAG解决方案" class="headerlink" title="RAG解决方案"></a>RAG解决方案</h2><h3 id="RAG是什么？"><a href="#RAG是什么？" class="headerlink" title="RAG是什么？"></a>RAG是什么？</h3><p><strong>RAG</strong>（Retrieval-Augmented Generation）也叫<strong>检索增强生成</strong>，是指对大语言模型输出进行优化，使其能够参考并利用数据源之外的权威知识。简单来说，RAG就是从外部检索对应的知识内容，和用户的提问一起构成Prompt发给大模型，再让大模型生成内容。</p><p>它的核心思想是：</p><ol><li><strong>从外部知识库检索相关信息</strong></li><li><strong>将检索到的信息作为上下文提供给模型</strong></li><li><strong>让模型基于这些上下文生成回答</strong></li></ol><p>简单来说：RAG &#x3D; 外部知识检索 + Prompt构建 + LLM 生成</p><p><img src="/medias/featureimages/blog/da-mo-xing-rag-ying-yong-kai-fa-ji-chu-ji-ru-men/image1.png" alt="image"></p><h3 id="为什么需要RAG？"><a href="#为什么需要RAG？" class="headerlink" title="为什么需要RAG？"></a>为什么需要RAG？</h3><p>LLM虽然是一个强大的工具，但它本身拒绝了解任何时事，且它给出的答案总是非常流畅，内容却不一定靠谱。这存在几个主要的问题:</p><ol><li>LLM的训练数据量有限且无法更新到最新知识。</li><li>当用户需要专业或领域特定的数据时，LLM往往缺乏相应的知识</li><li>对于答案的问答内容很难从源创进行溯源</li><li>由于技术限制，不同的训练源使用相同的大语言技术，可能会产生不确信的响应</li></ol><p>而RAG为解决这些问题带来了以下优势：</p><ul><li><strong>经济高效</strong>：预训练和微调模型的成本很高，而RAG是一种经济高效的新方法</li><li><strong>信息时效</strong>：使用RAG可以为LLM提供最新的研究、统计数据或新闻</li><li><strong>增强用户信任度</strong>：RAG允许LLM通过来源归属来呈现具体的信息，输出可以包括对来源的引文或参考，这可以增加对对话的生成式人工智能解决方案的任何信心</li></ul><h3 id="RAG是如何工作的？"><a href="#RAG是如何工作的？" class="headerlink" title="RAG是如何工作的？"></a>RAG是如何工作的？</h3><p>RAG采用三种主要的检索方式：</p><ol><li><strong>一次性检索</strong>：<ul><li>从单次检索中获取相关知识</li><li>直接预置到大模型的提示词中</li><li>不会收集反馈信息</li></ul></li><li><strong>迭代检索</strong>：<ul><li>允许在对话过程中多次检索</li><li>每一轮都可能有新的检索</li><li>支持多轮对话优化</li></ul></li><li><strong>事后检索</strong>：<ul><li>先生成答案</li><li>然后检索验证</li><li>对答案进行修正</li></ul></li></ol><p><img src="/medias/featureimages/blog/da-mo-xing-rag-ying-yong-kai-fa-ji-chu-ji-ru-men/image2.png" alt="image"></p><h3 id="RAG实战示例"><a href="#RAG实战示例" class="headerlink" title="RAG实战示例"></a>RAG实战示例</h3><p>以一个简单的问答场景为例，展示RAG的实际应用流程:</p><ol><li>用户提问:”公司有销售什么产品？”</li><li>系统处理流程:<ul><li>使用检索器获取产品相关文档</li><li>将文档内容与问题组合成提示词</li><li>通过LLM生成回答</li><li>确保回答基于检索到的事实信息</li></ul></li><li>最终输出:包含准确的产品信息，并且所有信息都可以溯源。</li></ol><h2 id="AI应用开发利器：向量数据库详解"><a href="#AI应用开发利器：向量数据库详解" class="headerlink" title="AI应用开发利器：向量数据库详解"></a>AI应用开发利器：向量数据库详解</h2><h3 id="什么是向量数据库？"><a href="#什么是向量数据库？" class="headerlink" title="什么是向量数据库？"></a>什么是向量数据库？</h3><p>向量数据库（Vector Database）是一种专门用于存储和处理向量数据的数据库系统。它不同于传统的关系型数据库，因为它需要将所有数据映射为特定的向量格式，并采用相似性搜索作为主要的检索方式。</p><h3 id="一个生动的例子：识别猫咪"><a href="#一个生动的例子：识别猫咪" class="headerlink" title="一个生动的例子：识别猫咪"></a>一个生动的例子：识别猫咪</h3><p>让我们通过一个识别猫咪的例子来理解向量数据库。假设我们有一组不同品种的猫咪图片：</p><ul><li>波斯猫</li><li>英国短毛猫</li><li>暹罗猫</li><li>布偶猫</li><li>无毛猫</li></ul><p>每张猫咪图片都可以用一组数字向量来表示其特征，如:</p><pre class="line-numbers language-language-json"><code class="language-language-json">波斯猫: [0.4, 0.3, 0.4, 0.5, 0.3, 0.4, 0.5, ...]英国短毛猫: [0.7, 0.2, 0.5, 0.5, 0.5, 0.5, 0.5, ...]暹罗猫: [0.5, 0.3, 0.4, 0.5, 0.3, 0.4, 0.5, ...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这些数字代表了猫咪的各种特征，比如:</p><ul><li>毛发长度</li><li>体型大小</li><li>面部特征</li><li>耳朵形状等等</li></ul><h3 id="向量数据库的优势"><a href="#向量数据库的优势" class="headerlink" title="向量数据库的优势"></a>向量数据库的优势</h3><p>与传统的数据库相比，向量数据库有以下特点：</p><ol><li><strong>数据类型</strong>：<ul><li>传统数据库：数值、字符串、时间等结构化数据</li><li>向量数据库：向量数据(不存储原始数据，有的也支持)</li></ul></li><li><strong>数据规模</strong>：<ul><li>传统数据库：小，1亿条数据对关系型数据库来说规模很大</li><li>向量数据库：大，最少千亿数据是基线</li></ul></li><li><strong>数据组织方式</strong>：<ul><li>传统数据库：基于表格、按照行和列组织</li><li>向量数据库：基于向量、按向量维度组织</li></ul></li><li><strong>查找方式</strong>：<ul><li>传统数据库：精确查找&#x2F;范围查找</li><li>向量数据库：近似查找，查询结果是与输入向量最相似的向量</li></ul></li></ol><h3 id="相似性搜索算法"><a href="#相似性搜索算法" class="headerlink" title="相似性搜索算法"></a>相似性搜索算法</h3><p>在向量数据库中，支持通过多种方式来计算两个向量的相似度：</p><p><strong>余弦相似度</strong>：主要是用于衡量向量在方向上的相似性，特别适用于文本、图像和高维空间中的向量。它不受向量长度的影响，只考虑方向的相似程度，计算公式如下（计算两个向量间的夹角的余弦值，取值范围为[-1, 1]）：</p><pre class="line-numbers language-language-bash"><code class="language-language-bash">similarity(A,B) = (A·B)/(||A||·||B||)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>欧式距离</strong>：主要是用于衡量向量之间的直线距离，得到的值可能很大，最小为0，通常用于低维空间或需要考虑向量各个维度之间差异的情况。欧式距离较小的向量被认为更相似，计算公式如下：</p><pre class="line-numbers language-language-bash"><code class="language-language-bash">distance(A,B) = √∑(Ai-Bi)²<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如下图：左侧就是<code>欧式距离</code>，右侧就是<code>余弦相似度</code>。</p><p><img src="/medias/featureimages/blog/da-mo-xing-rag-ying-yong-kai-fa-ji-chu-ji-ru-men/image3.png" alt="image"></p><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p>向量数据库的主要应用场景包括：</p><ol><li>人脸识别</li><li>图像搜索</li><li>音频识别</li><li>智能推荐系统</li></ol><p>这些场景的共同特点是：需要对非结构化数据（如图片、文本、音频）进行相似度搜索。</p><p>在RAG中，我们会将文档的知识按特定规则分成小块，转换成向量存储到向量数据库中。当人类提问时，我们将问题转换为向量，在数据库中找到最相似的文本块，这些文本块可以成为Prompt的补充内容。</p><h2 id="深入理解Embedding嵌入技术"><a href="#深入理解Embedding嵌入技术" class="headerlink" title="深入理解Embedding嵌入技术"></a>深入理解Embedding嵌入技术</h2><h3 id="Embedding-是什么？"><a href="#Embedding-是什么？" class="headerlink" title="Embedding 是什么？"></a>Embedding 是什么？</h3><p>Embedding(嵌入)是一种在机器学习中广泛使用的技术，它能将文本、图片、视频等非结构化数据映射到向量空间中。一个Embedding向量通常是一个包含N个浮点数的数组，这个向量不仅表示了数据的特征，更重要的是通过学习可以表达它们的内在语义。简而言之，Embedding就是一个模型生成方法，可以将非结构化的数据，例如文本&#x2F;图片&#x2F;视频等数据映射成有意义的向量数据。比如一段文本、一张图片、一段视频，警告Embedding模型处理后都会变成类似这样的向量：</p><pre class="line-numbers language-language-bash"><code class="language-language-bash">[0.5, 0.8, 0.7, 0.5, 0.8, 0.7, 0.5, 0.8, 0.7, 0.5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/medias/featureimages/blog/da-mo-xing-rag-ying-yong-kai-fa-ji-chu-ji-ru-men/image4.png" alt="image"></p><h3 id="主流的Embedding模型"><a href="#主流的Embedding模型" class="headerlink" title="主流的Embedding模型"></a>主流的Embedding模型</h3><p>目前主要有这几类Embedding模型：</p><ol><li><strong>Word2Vec（词嵌入模型）</strong><ul><li>通过学习词语转化为连续的向量表示</li><li>基于两种主要算法：<code>CBOW</code> 和 <code>Skip-gram</code></li><li>能够捕捉词语之间的语义关系</li></ul></li><li><strong>1GloVe</strong><ul><li>类似Word2Vec但采用不同的训练方式</li><li>同时考虑全局共现信息</li><li>能较好地保存词语间的语义关系</li><li>适用于多种自然语言处理任务</li></ul></li><li><strong>FastText</strong><ul><li>考虑了单词的子词信息</li><li>能处理训练集中未出现的生词</li><li>支持多语言处理</li></ul></li><li><strong>大模型Embeddings</strong><ul><li>如OpenAI的text-embedding-ada-002</li><li>输入维度8191个tokens</li><li>输出维度1536维向量</li></ul></li></ol><h3 id="Embedding的神奇之处"><a href="#Embedding的神奇之处" class="headerlink" title="Embedding的神奇之处"></a>Embedding的神奇之处</h3><p>Embedding最有趣的特性是它能够捕捉语义关系。让我们看一个著名的例子</p><pre class="line-numbers language-language-bash"><code class="language-language-bash">King - Man + Woman ≈ Queen(国王 - 男人 + 女人 ≈ 女王)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个公式展示了Embedding不仅仅是把词语转换成数字，它还能：</p><ol><li>保留词语之间的关系</li><li>支持向量运算</li><li>产生有意义的结果</li></ol><p>我们可以通过可视化的方式看到这些词语在向量空间中的分布：</p><ul><li>woman和girl的向量位置接近</li><li>man和boy的向量位置接近</li><li>king和queen虽然性别不同，但都位于表示”统治者”的维度上</li></ul><h3 id="Embedding的重要价值"><a href="#Embedding的重要价值" class="headerlink" title="Embedding的重要价值"></a>Embedding的重要价值</h3><ol><li><strong>降维</strong>：将高维数据映射到低维空间，大大降低了计算复杂度</li><li><strong>捕捉语义信息</strong>：不仅能记录表面的词频信息，还能捕捉深层的语义关联</li><li><strong>泛化性</strong>：Embedding学习到的是通用的语言表达方式，可以应用到新的场景</li><li><strong>泛化能力</strong>：对于未见过的数据，也能基于已学习的语义特征给出合理的向量表示</li><li><strong>可视化支持</strong>：虽然Embedding本身很复杂，但我们可以使用t-SNE等工具将其可视化，帮助理解数据的内在结构。</li></ol><h3 id="在RAG中的应用"><a href="#在RAG中的应用" class="headerlink" title="在RAG中的应用"></a>在RAG中的应用</h3><p>在RAG系统中，Embedding主要用于两个场景：</p><ol><li><strong>文档向量化</strong>：将知识库中的文档转换为向量</li><li><strong>查询向量化</strong>：将用户的问题转换为向量</li></ol><p>通过比较这些向量的相似度，我们可以找到与用户问题最相关的文档片段，从而提供更准确的答案。</p><h2 id="RAG应用实战-OpenAI-Embedding与LangChain的结合"><a href="#RAG应用实战-OpenAI-Embedding与LangChain的结合" class="headerlink" title="RAG应用实战:OpenAI Embedding与LangChain的结合"></a>RAG应用实战:OpenAI Embedding与LangChain的结合</h2><h3 id="OpenAI-Embedding接口简介"><a href="#OpenAI-Embedding接口简介" class="headerlink" title="OpenAI Embedding接口简介"></a>OpenAI Embedding接口简介</h3><p>OpenAI提供了多个Embedding模型选择，以下是几个主要模型的对比:</p><table><thead><tr><th>模型</th><th>Token数(每个文档800个)</th><th>性能评估</th><th>最大输入</th><th>向量维度</th></tr></thead><tbody><tr><td>text-embedding-3-small</td><td>62,500</td><td>62.3%</td><td>8191</td><td>1536</td></tr><tr><td>text-embedding-3-large</td><td>9,615</td><td>64.6%</td><td>8191</td><td>3072</td></tr><tr><td>text-embedding-ada-002</td><td>12,500</td><td>61.0%</td><td>8191</td><td>1536</td></tr></tbody></table><h3 id="LangChain中的Embedding组件使用"><a href="#LangChain中的Embedding组件使用" class="headerlink" title="LangChain中的Embedding组件使用"></a>LangChain中的Embedding组件使用</h3><p>在LangChain中，Embedding类提供了统一的接口来使用各种嵌入模型:</p><pre class="line-numbers language-language-bash"><code class="language-language-bash">class Embeddings(ABC):    """Interface for embedding models."""        @abstractmethod    def embed_documents(self, texts: List[str]) -> List[List[float]]:        """Embed search docs."""            @abstractmethod    def embed_query(self, text: str) -> List[float]:        """Embed query text."""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用示例:</p><pre class="line-numbers language-language-python"><code class="language-language-python">import dotenvimport numpy as npfrom langchain_openai import OpenAIEmbeddingsfrom numpy.linalg import norm# 初始化Embedding模型embeddings = OpenAIEmbeddings()# 进行文本嵌入query_vector = embeddings.embed_query("你好, 我是小潘")documents_vector = embeddings.embed_documents([    "你好, 我是小潘",    "这个自然语言处理的人叫小潘",    "来知若惘, 既心若旷"])# 计算相似度def cosine_similarity(vector1, vector2):    dot_product = np.dot(vector1, vector2)    norm1 = norm(vector1)    norm2 = norm(vector2)    return dot_product / (norm1 * norm2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CacheBackEmbedding的使用"><a href="#CacheBackEmbedding的使用" class="headerlink" title="CacheBackEmbedding的使用"></a>CacheBackEmbedding的使用</h3><p>为了提高性能，LangChain提供了缓存功能：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain.embeddings import CacheBackedEmbeddingsfrom langchain.storage import LocalFileStoreembeddings = OpenAIEmbeddings(model="text-embedding-3-small")embeddings_with_cache = CacheBackedEmbeddings.from_bytes_store(    embeddings,    LocalFileStore("./cache/"),    namespace=embeddings.model,    query_embedding_cache=True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用缓存时需要注意：</p><ol><li>underlying_embedder: 使用的基础嵌入模型</li><li>document_embedding_cache: 用于缓存文档的存储结构</li><li>batch_size: 可选参数，默认None</li><li>namespace: 用于文档缓存的命名空间</li><li>query_embedding_cache: 是否缓存查询向量</li></ol><h3 id="运行流程分析"><a href="#运行流程分析" class="headerlink" title="运行流程分析"></a>运行流程分析</h3><p>一个完整的RAG应用运行流程如下：</p><ol><li><strong>文档预处理</strong><ul><li>分割文档</li><li>生成向量</li><li>存入向量数据库</li></ul></li><li><strong>查询处理</strong><ul><li>将用户问题转为向量</li><li>在向量数据库中检索</li><li>组合上下文生成回答</li></ul></li><li><strong>缓存优化</strong><ul><li>缓存常见文档的向量</li><li>缓存常见查询的向量</li><li>提供响应速度</li></ul></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>向量维度的选择<ul><li>需要平衡精度和效率</li><li>维度越高，表达能力越强，但计算成本也越高</li></ul></li><li>缓存策略<ul><li>合理设置缓存大小</li><li>选择适当的缓存淘汰策略</li><li>定期更新缓存</li></ul></li><li>性能优化<ul><li>使用批处理提高效率</li><li>合理使用多线程</li><li>监控资源使用情况</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain RAG 应用开发优化策略详解</title>
      <link href="/2025/02/12/langchain-rag-ying-yong-kai-fa-you-hua-ce-lue-xiang-jie/"/>
      <url>/2025/02/12/langchain-rag-ying-yong-kai-fa-you-hua-ce-lue-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="引言：理解RAG及其重要性"><a href="#引言：理解RAG及其重要性" class="headerlink" title="引言：理解RAG及其重要性"></a>引言：理解RAG及其重要性</h2><p>在大语言模型（LLM）应用开发中，检索增强生成（Retrival-Augmented Generation, RAG）已经成为提升模型输出质量的关键技术。本文将深入探讨在LangChain框架中如何优化RAG应用，帮助开发者构建更智能、更准确的AI应用。</p><h2 id="RAG的基本概念"><a href="#RAG的基本概念" class="headerlink" title="RAG的基本概念"></a>RAG的基本概念</h2><blockquote><p>📌 什么是RAG?<br>RAG是一种将外部知识检索与语言模型生成相结合的技术架构。它通过检索相关信息来增强LLM的知识储备，从而产生更准确、更可靠的输出。</p></blockquote><h3 id="为什么需要优化RAG？"><a href="#为什么需要优化RAG？" class="headerlink" title="为什么需要优化RAG？"></a>为什么需要优化RAG？</h3><p>在实际应用中，基础的RAG实现往往会遇到以下挑战：</p><ol><li>检索准确性不足</li><li>复杂问题处理能力有限</li><li>知识关联不够紧密</li><li>响应质量不够稳定</li></ol><p>这些问题促使我们需要采用多种优化策略来提升RAG的性能。</p><h3 id="第一部分：多查询检索优化策略"><a href="#第一部分：多查询检索优化策略" class="headerlink" title="第一部分：多查询检索优化策略"></a>第一部分：多查询检索优化策略</h3><h4 id="理解多查询检索的必要性"><a href="#理解多查询检索的必要性" class="headerlink" title="理解多查询检索的必要性"></a>理解多查询检索的必要性</h4><p>在RAG应用中，单一查询往往无法完整捕捉用户问题的所有方面。例如，当用户问”Python如何实现多线程并发控制？“时，我们可能需要同时检索：</p><ul><li>Python线程基础知识</li><li>并发控制机制</li><li>线程安全实现方法</li></ul><h4 id="多查询检索的工作原理"><a href="#多查询检索的工作原理" class="headerlink" title="多查询检索的工作原理"></a>多查询检索的工作原理</h4><blockquote><p>🔍 核心思路：利用LLM的理解能力，将一个复杂查询拆分或重写为多个相关查询，然后通过融合算法整合检索结果。</p></blockquote><p><strong>工作流程</strong>：</p><ol><li><strong>查询重写</strong>：LLM将原始查询转换为多个相关查询</li><li><strong>并行检索</strong>：对每个查询进行独立检索</li><li><strong>结果融合</strong>：使用RRF（Reciprocal Rank Fusion）算法融合检索结果</li><li><strong>内容生成</strong>：将融合后的结果输入LLM生成最终答案</li></ol><h3 id="代码实现示例"><a href="#代码实现示例" class="headerlink" title="代码实现示例"></a>代码实现示例</h3><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain.retrievers import MultiQueryRetrieverfrom langchain.chains import LLMChainfrom langchain.prompts import PromptTemplate# 1. 创建多查询检索器retriever = MultiQueryRetriever(    retriever=base_retriever,    llm=ChatOpenAI(model="gpt-3.5-turbo-16k", temperature=0),    prompt_template="""基于用户的问题，生成3个不同的相关查询：    原始问题: &#123;question&#125;    生成的查询应该探索问题的不同方面。    """)# 2. 使用RRF算法融合结果def rrf_fusion(results, k=60):    fused_scores = &#123;&#125;    for rank, doc in enumerate(results):        doc_str = doc.page_content        if doc_str not in fused_scores:            fused_scores[doc_str] = 1.0 / (k + rank + 1)        else:            fused_scores[doc_str] += 1.0 / (k + rank + 1)        # 排序并返回结果    sorted_results = sorted(fused_scores.items(),                           key=lambda x: x[1],                           reverse=True)    return sorted_results<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RRF 算法原理如下</p><pre class="line-numbers language-language-python"><code class="language-language-python">"""RRF (Reciprocal Rank Fusion) 算法的核心公式：RRFscore(d ∈ D) = ∑ 1/(k + r(d))其中：- d 是文档- D 是所有文档集合- k 是一个常数(通常取60)- r(d)是文档d在排序中的位置这个公式的特点：1. 对排名靠前的文档给予更高的权重2. k参数可以调节排名的影响程度3. 适合融合不同来源的排序结果"""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优化效果分析"><a href="#优化效果分析" class="headerlink" title="优化效果分析"></a>优化效果分析</h4><p>多查询检索策略带来的主要优势：</p><ol><li><strong>提升召回率</strong><ul><li>通过多角度查询提高相关文档的覆盖率</li><li>减少因单一查询表达不当导致的漏检</li></ul></li><li><strong>提高准确性</strong><ul><li>RRF融合算法可以突出高质量的共同结果</li><li>降低单个查询的噪声影响</li></ul></li><li><strong>增强鲁棒性</strong><ul><li>对查询表达的变化更不敏感</li><li>能更好地处理复杂或模糊的问题</li></ul></li></ol><h4 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h4><p>在实际应用中，需要注意以下几点：</p><ul><li><strong>查询数量选择</strong>：通常生成3-5个查询即可，过多查询可能引入噪声</li><li><strong>相似度阈值设置</strong>：建议在RRF融合时设置合适的相似度阈值，过滤低相关性结果</li><li><strong>资源消耗考虑</strong>：多查询会增加API调用和计算资源，需要在效果和成本间权衡</li></ul><blockquote><p>💡 实践小贴士：可以通过监控检索结果的diversity和relevance指标，来调整多查询策略的参数。</p></blockquote><h3 id="第二部分：问题分解策略优化"><a href="#第二部分：问题分解策略优化" class="headerlink" title="第二部分：问题分解策略优化"></a>第二部分：问题分解策略优化</h3><h4 id="复杂问题的分解处理"><a href="#复杂问题的分解处理" class="headerlink" title="复杂问题的分解处理"></a>复杂问题的分解处理</h4><p>在实际应用中，我们经常遇到复杂的多层次问题。例如：”请分析特斯拉近五年的财务状况，并评估其在电动汽车市场的竞争优势。”这类问题需要：</p><ul><li>处理大量相关信息</li><li>分析多个维度</li><li>综合多方面结论</li></ul><p><strong>并行分解模式</strong>:</p><blockquote><p>🔄 并行模式：将问题同时分解为多个独立子问题，分别获取答案后合并。</p></blockquote><pre class="line-numbers language-language-python"><code class="language-language-python"># 并行分解示例decomposition_chain = &#123;    "question": RunnablePassthrough(),    | decomposition_prompt    # 分解问题    | ChatOpenAI(temperature=0)    | StrOutputParser()&#125;# 并行处理子问题sub_questions = decomposition_chain.invoke(question)answers = await asyncio.gather(*[    process_subquestion(q) for q in sub_questions])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>串行分解模式</strong>:</p><blockquote><p>⛓️ 串行模式：按照逻辑顺序依次处理子问题，后面的问题依赖前面的答案。</p></blockquote><pre class="line-numbers language-language-python"><code class="language-language-python"># 串行分解示例class StepBackRetriever(BaseRetriever):    def _get_relevant_documents(        self, query: str, *, run_manager: CallbackManagerForRetrieverRun    ) -> List[Document]:        # 1. 生成中间查询        intermediate_query = self.llm.predict(            f"为了回答'&#123;query&#125;'，我们需要先了解什么？"        )                # 2. 检索中间知识        intermediate_docs = self.retriever.get_relevant_documents(            intermediate_query        )                # 3. 基于中间知识检索最终答案        final_docs = self.retriever.get_relevant_documents(query)                return intermediate_docs + final_docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Step-Back-策略实现"><a href="#Step-Back-策略实现" class="headerlink" title="Step-Back 策略实现"></a>Step-Back 策略实现</h4><p>Step-Back策略是一种特殊的串行分解方法，它通过“后退一步”来获取更基础的知识背景。</p><pre class="line-numbers language-language-python"><code class="language-language-python">"""示例：用户问题"量子计算机如何影响现代密码学？"Step-Back分解：1. 基础知识查询：   - 什么是量子计算机的基本原理？   - 现代密码学的核心技术有哪些？2. 关联分析：   - 量子计算对RSA等算法的影响   - 后量子密码学的发展3. 最终综合：   基于以上知识形成完整答案"""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>工作流程</strong>：</p><ol><li>分析原始问题</li><li>生成更基础的前置问题</li><li>获取基础知识</li><li>结合基础知识回答原问题</li></ol><h4 id="Step-Back-代码实现"><a href="#Step-Back-代码实现" class="headerlink" title="Step-Back 代码实现"></a>Step-Back 代码实现</h4><pre class="line-numbers language-language-python"><code class="language-language-python">system_prompt = """你是一位专业的助手，需要：1. 理解用户的具体问题2. 思考需要哪些基础知识3. 生成相关的基础问题4. 基于基础知识回答原问题"""few_shot_prompt = FewShotChatMessagePromptTemplate(    example_prompt=example_prompt,    examples=examples,    suffix="现在，请帮我回答：&#123;question&#125;")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优化效果对比"><a href="#优化效果对比" class="headerlink" title="优化效果对比"></a>优化效果对比</h4><table><thead><tr><th>分解策略</th><th>适用场景</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>并行分解</td><td>独立子问题</td><td>处理速度快，资源利用高</td><td>结果整合可能不够连贯</td></tr><tr><td>串行分解</td><td>逻辑依赖性强</td><td>答案更连贯，逻辑性强</td><td>处理时间较长</td></tr><tr><td>Step-Back</td><td>需要深入理解</td><td>回答更全面，准确度高</td><td>资源消耗较大</td></tr></tbody></table><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><ol><li>选择策略时考虑因素:<ul><li>问题的复杂度</li><li>子问题间的依赖关系</li><li>响应时间要求</li><li>资源限制</li></ul></li><li>优化建议：<ul><li>对于并行模式，注意结果融合的质量</li><li>串行模式要控制分解的层级深度</li><li>Step-Back策略要平衡基础知识的范围</li></ul></li></ol><blockquote><p>🌟 最佳实践：可以根据问题类型动态选择分解策略，甚至组合使用多种策略。</p></blockquote><h3 id="第三部分：混合检索策略实现"><a href="#第三部分：混合检索策略实现" class="headerlink" title="第三部分：混合检索策略实现"></a>第三部分：混合检索策略实现</h3><h4 id="理解混合检索的价值"><a href="#理解混合检索的价值" class="headerlink" title="理解混合检索的价值"></a>理解混合检索的价值</h4><p>在实际应用中，单一的检索方法往往难以应对所有场景。例如：</p><ul><li>语义检索擅长理解上下文，但可能错过关键词</li><li>关键词检索准确度高，但缺乏语义理解</li><li>密集检索和稀疏检索各有优势</li></ul><p>因此，将多种检索方法结合起来，可以取长补短，提升整体检索效果。</p><h4 id="混合检索器的架构设计"><a href="#混合检索器的架构设计" class="headerlink" title="混合检索器的架构设计"></a>混合检索器的架构设计</h4><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain.retrievers import EnsembleRetrieverfrom langchain_community.retrievers import BM25Retrieverfrom langchain_community.vectorstores import FAISS# 1. 创建不同类型的检索器# BM25检索器（基于关键词）bm25_retriever = BM25Retriever.from_documents(    documents, k=4)# FAISS检索器（基于向量）faiss_retriever = FAISS.from_documents(    documents,    embedding=OpenAIEmbeddings(model="text-embedding-3-small")).as_retriever(search_kwargs=&#123;"k": 4&#125;)# 2. 创建集成检索器ensemble_retriever = EnsembleRetriever(    retrievers=[bm25_retriever, faiss_retriever],    weights=[0.5, 0.5])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="主要检索方法的特点"><a href="#主要检索方法的特点" class="headerlink" title="主要检索方法的特点"></a>主要检索方法的特点</h4><p>下面是几种常用检索方法的对比：</p><table><thead><tr><th>检索方法</th><th>优势</th><th>适用场景</th><th>注意事项</th></tr></thead><tbody><tr><td>BM25</td><td>精确匹配，速度快</td><td>关键词搜索</td><td>不理解语义变化</td></tr><tr><td>向量检索</td><td>理解语义相似</td><td>概念搜索</td><td>计算资源消耗大</td></tr><tr><td>混合检索</td><td>综合优势</td><td>复杂查询</td><td>需要调整权重</td></tr></tbody></table><h4 id="实现细节和优化"><a href="#实现细节和优化" class="headerlink" title="实现细节和优化"></a>实现细节和优化</h4><p><strong>检索器配置</strong>:</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 配置检索参数faiss_retriever = faiss_db.as_retriever(    search_kwargs=&#123;"k": 4&#125;).configurable_fields(    search_kwargs=ConfigurableField(        id="search_kwargs_faiss",        name="检索参数",        description="设置检索的参数"    ))# 设置运行时配置config = &#123;"configurable": &#123;"search_kwargs_faiss": &#123;"k": 4&#125;&#125;&#125;docs = ensemble_retriever.invoke("查询", config=config)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>权重调整策略</strong>:</p><ol><li><strong>初始设置</strong>：开始时可以给各检索器相同权重</li><li><strong>动态调整</strong>：根据查询类型动态调整权重</li><li><strong>性能监控</strong>：跟踪各检索器的表现，定期优化权重</li><li><strong>场景适配</strong>：针对不同领域调整最优权重组合</li></ol><h4 id="应用效果优化"><a href="#应用效果优化" class="headerlink" title="应用效果优化"></a>应用效果优化</h4><p>为了获得最佳检索效果，建议：</p><ol><li>检索器选择<ul><li>根据数据特点选择合适的检索器组合</li><li>考虑计算资源和响应时间的平衡</li><li>评估检索器的互补性</li></ul></li><li>参数优化<ul><li>使用验证集调整检索参数</li><li>监控检索质量指标</li><li>定期更新检索模型</li></ul></li><li>结果融合<ul><li>采用多样化的融合策略</li><li>考虑结果的去重和排序</li><li>平衡相关性和多样性</li></ul></li></ol><h4 id="性能监控与改进"><a href="#性能监控与改进" class="headerlink" title="性能监控与改进"></a>性能监控与改进</h4><pre class="line-numbers language-language-python"><code class="language-language-python"># 性能监控示例def evaluate_retrieval(retriever, test_queries, ground_truth):    metrics = &#123;        'precision': [],        'recall': [],        'latency': []    &#125;        for query, truth in zip(test_queries, ground_truth):        start_time = time.time()        results = retriever.get_relevant_documents(query)        latency = time.time() - start_time                # 计算评估指标        metrics['latency'].append(latency)        # ... 计算precision和recall            return metrics    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结：RAG优化策略的实践指南"><a href="#总结：RAG优化策略的实践指南" class="headerlink" title="总结：RAG优化策略的实践指南"></a>总结：RAG优化策略的实践指南</h3><h4 id="优化策略的综合比较"><a href="#优化策略的综合比较" class="headerlink" title="优化策略的综合比较"></a>优化策略的综合比较</h4><p>以下是我们讨论过的主要优化策略的特点对比：</p><table><thead><tr><th>优化策略</th><th>主要优势</th><th>实现复杂度</th><th>资源消耗</th><th>适用场景</th></tr></thead><tbody><tr><td>多查询检索</td><td>提高召回率</td><td>中等</td><td>中等</td><td>复杂查询、模糊问题</td></tr><tr><td>问题分解</td><td>提升理解深度</td><td>较高</td><td>较高</td><td>多维度分析问题</td></tr><tr><td>Step-Back</td><td>增强理解准确性</td><td>高</td><td>高</td><td>需要深入理解的问题</td></tr><tr><td>混合检索</td><td>综合性能提升</td><td>中等</td><td>较高</td><td>通用场景</td></tr></tbody></table><h4 id="优化路径建议"><a href="#优化路径建议" class="headerlink" title="优化路径建议"></a>优化路径建议</h4><ol><li><strong>基础阶段</strong><ul><li>实现基本的RAG流程</li><li>优化向量检索参数</li><li>改进提示词设计</li></ul></li><li><strong>进阶阶段</strong><ul><li>引入多查询策略</li><li>实现基本的问题分解</li><li>尝试混合检索方法</li></ul></li><li><strong>高级阶段</strong><ul><li>实现完整的Step-Back策略</li><li>优化多检索器集成</li><li>构建自适应检索系统</li></ul></li></ol><p><strong>场景选择指南</strong>:</p><p>根据不同的应用场景，推荐以下优化组合：</p><ol><li><strong>知识问答系统</strong><ul><li>多查询检索 + 混合检索</li><li>重点优化检索准确性</li></ul></li><li><strong>文档分析系统</strong><ul><li>问题分解 + Step-Back</li><li>强化深度理解能力</li></ul></li><li><strong>通用对话系统</strong><ul><li>混合检索 + 多查询</li><li>平衡效率和准确性</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Langchain </tag>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain初入门</title>
      <link href="/2025/02/09/langchain-chu-ru-men/"/>
      <url>/2025/02/09/langchain-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么选择LangChain"><a href="#为什么选择LangChain" class="headerlink" title="为什么选择LangChain"></a>为什么选择LangChain</h2><p>LangChain作为一个强大的框架，具有以下优势：</p><ul><li><p><strong>组件化和标准化</strong>：提供了标准化的接口来处理各种LLM，使开发更加灵活和可维护。</p></li><li><p><strong>丰富的工具集成</strong>：内置了大量工具和集成，可以轻松连接数据库、搜索引擎等外部服务。</p></li><li><p><strong>链式处理能力</strong>：可以将多个组件组合成链，实现复杂的处理流程。</p></li><li><p><strong>内存管理</strong>：提供了多种记忆组件，使应用能够保持上下文连贯性。</p></li></ul><h2 id="LangChain简介"><a href="#LangChain简介" class="headerlink" title="LangChain简介"></a>LangChain简介</h2><p>LangChain是一个用于开发由语言模型驱动的应用程序的框架。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li><p><strong>Models (模型)</strong>：提供与大语言模型的统一交互接口，支持各类LLM、聊天模型和文本嵌入模型的调用</p></li><li><p><strong>Prompts (提示)</strong>：专门用于管理和优化提示模板，提供标准化的提示工程工具</p></li><li><p><strong>Indexes (索引)</strong>：提供高效的文档加载、分割和向量存储系统，支持大规模文本处理和检索</p></li><li><p><strong>Memory (记忆)</strong>：用于在交互过程中管理和存储状态信息，确保对话的连贯性和上下文理解</p></li><li><p><strong>Chains (链)</strong>：能将多个组件组合成端到端应用的核心机制，实现复杂的处理流程</p></li><li><p><strong>Agents (代理)</strong>：赋予LLM使用工具的能力，支持自主推理和行动决策</p></li></ul><p><img src="/medias/featureimages/blog/langchain-chu-ru-men/image1.png" alt="image"></p><h4 id="Prompts组件"><a href="#Prompts组件" class="headerlink" title="Prompts组件"></a>Prompts组件</h4><p><strong>概念与作用</strong>:</p><p>在LLM应用开发中,我们通常不会直接将用户输入传递给大模型,而是会将用户输入添加到一个更大的文本片段中,这个文本片段被称为Prompt。Prompt为大模型提供了任务相关的上下文和指令,帮助模型更好地理解和执行任务。</p><p>LangChain中的Prompts组件提供了一系列工具来管理和优化这些提示模板。主要包含两大类:</p><ul><li><p>PromptTemplate: 将Prompt按照template进行格式化,处理变量和组合</p></li><li><p>Selectors: 根据不同条件选择不同的提示词</p></li></ul><p><strong>基本构成</strong>:</p><p>在LangChain中,Prompts组件包含多个子组件:</p><p>角色提示模板:</p><ul><li><p>SystemMessagePromptTemplate: 系统角色消息模板</p></li><li><p>HumanMessagePromptTemplate: 人类角色消息模板</p></li><li><p>AIMessagePromptTemplate: AI角色消息模板</p></li></ul><p>提示模板类型:</p><ul><li><p>PromptTemplate: 文本提示模板</p></li><li><p>ChatPromptTemplate: 聊天消息提示模板</p></li><li><p>MessagePlaceholder: 消息占位符</p></li></ul><p><strong>关键操作</strong>:</p><p>格式化LangChain支持两种格式化方式</p><pre class="line-numbers language-language-python"><code class="language-language-python"># f-string方式prompt = PromptTemplate.from_template("请将一个关于&#123;subject&#125;的笑话")# jinja2方式prompt = PromptTemplate.from_template(    "请将一个关于&#123;&#123;subject&#125;&#125;的笑话",    template_format="jinja2")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提示模板拼接</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 字符串提示拼接prompt = (    PromptTemplate.from_template("请将一个关于&#123;subject&#125;的冷笑话")    + "，让我开心下"    + "\n使用&#123;language&#125;语言。")# 聊天提示拼接system_prompt = ChatPromptTemplate.from_messages([    ("system", "你是OpenAI开发的聊天机器人，请根据用户的提问进行回复，我叫&#123;username&#125;")])human_prompt = ChatPromptTemplate.from_messages([    ("human", "&#123;query&#125;")])prompt = system_prompt + human_prompt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>模板复用</strong>:</p><p>对于复杂的提示模板,LangChain提供了PipelinePromptTemplate来实现模板的复用:</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 描述提示模板instruction_template = "你正在模拟&#123;person&#125;。"instruction_prompt = PromptTemplate.from_template(instruction_template)# 示例提示模板example_template = """下面是一个交互例子:Q: &#123;example_q&#125;A: &#123;example_a&#125;"""example_prompt = PromptTemplate.from_template(example_template)# 开始提示模板start_template = """现在开始对话:Q: &#123;input&#125;A:"""start_prompt = PromptTemplate.from_template(start_template)# 组合模板pipeline_prompt = PipelinePromptTemplate(    final_prompt=full_prompt,    pipeline_prompts=[        ("instruction", instruction_prompt),        ("example", example_prompt),        ("start", start_prompt),    ])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最佳实践</strong>:</p><p>选择合适的格式化方式</p><ol><li><p>简单变量替换使用f-string</p></li><li><p>需要条件判断等复杂逻辑时使用jinja2</p></li></ol><p>提示模板设计</p><ol><li><p>保持模板的清晰和可维护性</p></li><li><p>合理使用系统消息和示例</p></li><li><p>避免过于复杂的嵌套结构</p></li></ol><p>错误处理</p><ol><li><p>验证必要的变量是否存在</p></li><li><p>处理格式化可能出现的异常</p></li></ol><p>性能优化</p><ol><li><p>重复使用的模板要缓存</p></li><li><p>避免不必要的模板拼接操作</p></li></ol><h4 id="Model组件"><a href="#Model组件" class="headerlink" title="Model组件"></a>Model组件</h4><p><strong>基本概念</strong>:</p><p>Models是LangChain的核心组件，提供了一个标准接口来封装不同类型的LLM进行交互，LangChain本身不提供LLM,而是提供了接口来集成各种模型。</p><p>LangChain支持两种类型的模型:</p><ul><li><p>LLM: 使用纯文本作为输入和输出的大语言模型</p></li><li><p>Chat Model: 使用聊天消息列表作为输入并返回聊天消息的聊天模型</p></li></ul><p><strong>组件架构</strong>:</p><p>LangChain中Models组件的基类结构如下:</p><p>BaseLanguageModel(基类)</p><p>BaseLLM(大语言模型基类)<br>    - SimpleLLM(简化大语言模型)<br>    - 第三方LLM集成(OpenAI、百度文心等)</p><p>BaseChatModel(聊天模型基类)<br>    - SimpleChatModel(简化聊天模型)<br>    - 第三方Chat Model集成</p><h4 id="Message组件"><a href="#Message组件" class="headerlink" title="Message组件"></a>Message组件</h4><ul><li><p>SystemMessage: 系统消息</p></li><li><p>HumanMessage: 人类消息</p></li><li><p>AIMessage: AI消息</p></li><li><p>FunctionMessage: 函数调用消息</p></li><li><p>ToolMessage: 工具调用消息</p></li></ul><p><strong>核心办法</strong>:</p><p>Models组件提供了几个关键方法:</p><p>invoke&#x2F;invoke_sync: 调用模型生成内容</p><pre class="line-numbers language-language-python"><code class="language-language-python">llm = ChatOpenAI(model="gpt-3.5-turbo-16k")response = llm.invoke("你好!")# 异步调用async def generate():    response = await llm.ainvoke("你好!")    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>batch&#x2F;abatch: 批量调用处理多个输入</p><pre class="line-numbers language-language-python"><code class="language-language-python">messages = [    "请讲一个关于程序员的笑话",    "请讲一个关于Python的笑话"]responses = llm.batch(messages)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>stream&#x2F;astream: 流式返回生成内容</p><pre class="line-numbers language-language-python"><code class="language-language-python">response = llm.stream("请介绍下LLM和LLMOps")for chunk in response:    print(chunk.content, end="")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Message组件使用</strong>:</p><p>消息组件用于构建与聊天模型的交互:</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.messages import SystemMessage, HumanMessage, AIMessage# 创建消息system_msg = SystemMessage(content="你是一个AI助手")human_msg = HumanMessage(content="你好!")ai_msg = AIMessage(content="你好!我是AI助手")# 构建消息列表messages = [system_msg, human_msg, ai_msg]# 使用消息与模型交互response = chat_model.invoke(messages)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实践示例</strong>:</p><p>基本对话示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_openai import ChatOpenAIfrom langchain_core.prompts import ChatPromptTemplate# 创建聊天模型chat = ChatOpenAI()# 创建提示模板prompt = ChatPromptTemplate.from_messages([    ("system", "你是一位&#123;role&#125;"),    ("human", "&#123;query&#125;")])# 调用模型response = chat.invoke(    prompt.format_messages(        role="Python专家",        query="什么是装饰器?"    ))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>流式输出示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">prompt = ChatPromptTemplate.from_template("&#123;subject&#125;的发展历史是什么?")# 创建模型llm = ChatOpenAI()# 流式生成response = llm.stream(    prompt.format_messages(subject="人工智能"))# 处理输出for chunk in response:    print(chunk.content, end="")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最佳实践</strong>:</p><p>选择合适的模型类型</p><ol><li><p>简单文本生成任务使用LLM</p></li><li><p>对话类任务使用Chat Model</p></li></ol><p>正确处理异步操作</p><ol><li><p>在异步环境中使用ainvoke&#x2F;astream</p></li><li><p>批量处理时考虑使用batch</p></li></ol><p>异常处理</p><ol><li><p>处理模型调用可能的超时</p></li><li><p>捕获API错误并适当处理</p></li></ol><p>性能优化</p><ol><li><p>合理使用批处理</p></li><li><p>适时使用流式输出</p></li></ol><p><strong>OutputParser 解析器组件</strong>:</p><p>为什么需要输出解析器</p><p>在使用大模型时,我们经常会遇到输出解析的问题。比如:</p><pre class="line-numbers language-language-python"><code class="language-language-python">llm = ChatOpenAI()# 示例1: 返回的是自然语言llm.invoke("1+1等于几?")  # 输出: 1 + 1 等于 2。# 示例2: 包含多余信息llm.invoke("告诉我3个动物的名字。")  # 输出: 好的，这里有三种动物的名字：\n1. 狮子\n2. 大熊猫\n3. 斑马# 示例3: 格式不统一llm.invoke("给我一个json数据,键为a和b")  # 输出: &#123;\n "a": 10,\n "b": 20\n&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OutputParser就是为了解决这些问题而设计的。它通过:</p><ol><li><p>预设提示 - 告诉LLM需要的输出格式</p></li><li><p>解析功能 - 将输出转换成指定格式</p></li></ol><p><strong>Parser类型详解</strong>:</p><p>Langchain 提供了多种Parser：</p><ol><li><p>基础Parser：</p><ul><li>StrOutputParser: 最简单的Parser,原样返回文本</li><li>BaseOutputParser: 所有Parser的基类</li><li>BaseLLMOutputParser: 专门用于LLM输出的基类</li></ul></li><li><p>格式化Parser：</p><ul><li>JsonOutputParser: 解析JSON格式输出</li><li>XMLOutputParser: 解析XML格式输出</li><li>PydanticOutputParser: 使用Pydantic模型解析输出</li></ul></li><li><p>列表类Parser：</p><ul><li>CommaSeparatedListOutputParser: 解析逗号分隔的列表</li><li>NumberedListOutputParser: 解析数字编号的列表</li></ul></li></ol><p><strong>实践示例</strong>:</p><ol><li>StrOutputParser使用：</li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_openai import ChatOpenAI# 创建链chain = (    ChatPromptTemplate.from_template("&#123;query&#125;")    | ChatOpenAI()    | StrOutputParser())# 调用response = chain.invoke(&#123;"query": "你好!"&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.JsonOutputParser使用：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.output_parsers import JsonOutputParserfrom langchain_core.pydantic_v1 import BaseModel, Field# 定义输出结构class Joke(BaseModel):    joke: str = Field(description="回答用户的冷笑话")    punchline: str = Field(description="冷笑话的笑点")# 创建Parserparser = JsonOutputParser(pydantic_object=Joke)# 创建提示模板prompt = ChatPromptTemplate.from_template(    "回答用户的问题。\n&#123;format_instructions&#125;\n&#123;query&#125;\n")# 添加格式说明prompt = prompt.partial(format_instructions=parser.get_format_instructions())# 创建链chain = prompt | ChatOpenAI() | parser# 使用response = chain.invoke(&#123;"query": "请讲一个关于程序员的冷笑话"&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>错误处理</strong>:</p><p>1.解析失败的处理：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.output_parsers import OutputParserExceptiontry:    result = parser.parse(llm_output)except OutputParserException as e:    # 处理解析错误    print(f"解析错误: &#123;e&#125;")    # 可以选择重试或使用默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.使用重试机制：</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 可以配置回调来处理重试from langchain_core.callbacks import BaseCallbackHandlerclass RetryHandler(BaseCallbackHandler):    def on_retry(self, retry_state):        print(f"重试次数: &#123;retry_state.attempt_number&#125;")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最佳实践</strong>:</p><ol><li><p>选择合适的Parser</p><ul><li>简单文本使用StrOutputParser</li><li>结构化数据使用JsonOutputParser或PydanticOutputParser</li><li>列表数据使用专门的列表Parser</li></ul></li><li><p>提示设计</p><ul><li>在提示中明确指定输出格式</li><li>使用Parser提供的format_instructions</li></ul></li><li><p>异常处理</p><ul><li>总是处理可能的解析错误</li><li>考虑添加重试机制</li><li>提供合理的默认值</li></ul></li><li><p>性能优化</p><ul><li>避免过于复杂的解析逻辑</li><li>合理使用缓存</li></ul></li></ol><h4 id="LCEL表达式与Runnable协议"><a href="#LCEL表达式与Runnable协议" class="headerlink" title="LCEL表达式与Runnable协议"></a>LCEL表达式与Runnable协议</h4><p><strong>为什么需要LCEL</strong>:</p><p>传统的链式调用方式存在嵌套问题：</p><pre class="line-numbers language-language-python"><code class="language-language-python">content = parser.invoke(    llm.invoke(        prompt.invoke(            &#123;"query": req.query.data&#125;        )    ))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LCEL 提供了更优雅的方式：</p><pre class="line-numbers language-language-python"><code class="language-language-python">chain = prompt | llm | parsercontent = chain.invoke(&#123;"query": req.query.data&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Runnable协议核心方法</strong>:</p><ul><li><p>invoke&#x2F;ainvoke: 调用组件</p></li><li><p>batch&#x2F;abatch: 批量处理</p></li><li><p>stream&#x2F;astream: 流式输出</p></li><li><p>transform: 转换输入输出</p></li></ul><p><strong>两个核心类</strong>:</p><ol><li>RunnableParallel - 并行执行多个Runnable</li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.runnables import RunnableParallel# 并行执行多个链chain = RunnableParallel(    joke=joke_chain,    poem=poem_chain)resp = chain.invoke(&#123;"subject": "程序员"&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.RunnablePassthrough - 传递数据</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.runnables import RunnablePassthrough# 构建检索链chain = (    RunnablePassthrough.assign(        context=lambda query: retrieval(query)    )    | prompt     | llm     | parser)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实践示例</strong>:</p><ol><li>基础链构建：</li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.prompts import ChatPromptTemplatefrom langchain_openai import ChatOpenAIfrom langchain_core.output_parsers import StrOutputParser# 创建组件prompt = ChatPromptTemplate.from_template("&#123;input&#125;")llm = ChatOpenAI()parser = StrOutputParser()# 构建链chain = prompt | llm | parser# 执行response = chain.invoke(&#123;"input": "Hello!"&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.带检索的链：</p><pre class="line-numbers language-language-python"><code class="language-language-python">def retrieval(query: str) -> str:    return "相关文档内容..."# 构建链chain = (    &#123;        "context": retrieval,        "question": RunnablePassthrough()    &#125;    | prompt    | llm    | StrOutputParser())# 执行response = chain.invoke("问题")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最佳实践</strong>:</p><ol><li><p>链的设计</p><ul><li>使用管道操作符(|)构建简单链</li><li>复杂逻辑使用RunnableParallel</li><li>数据传递用RunnablePassthrough</li></ul></li><li><p>错误处理</p><ul><li>合理使用try&#x2F;except</li><li>实现错误回调处理</li></ul></li><li><p>性能优化</p><ul><li>合适场景使用并行执行</li><li>批处理代替单个处理</li></ul></li><li><p>代码可维护性</p><ul><li>链结构保持清晰</li><li>适当拆分复杂链</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Langchain </tag>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain RAG 应用开发组件深度解析</title>
      <link href="/2025/02/09/langchain-rag-ying-yong-kai-fa-zu-jian-shen-du-jie-xi/"/>
      <url>/2025/02/09/langchain-rag-ying-yong-kai-fa-zu-jian-shen-du-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在当今的AI应用开发中，检索增强生成(Retrieval-Augmented Generation, RAG)已经成为一种重要的技术范式。它通过将大语言模型与外部知识库结合，极大地提升了AI系统的知识获取能力和输出质量。而LangChain作为一个强大的框架，为RAG应用的开发提供了丰富的组件支持。本文将深入剖析LangChain中RAG应用开发的核心组件，帮助你更好地理解和使用这些工具。</p><h2 id="核心组件概览"><a href="#核心组件概览" class="headerlink" title="核心组件概览"></a>核心组件概览</h2><p>在开始深入学习之前,我们先来了解LangChain中RAG应用开发涉及的主要组件:</p><ol><li>Document组件与文档加载器 - 负责文档的加载和基础处理</li><li>文档转换器与分割器 - 处理文档转换和分块</li><li>VectorStore组件 - 实现向量存储和检索</li><li>Blob相关组件 - 处理二进制大对象数据</li></ol><h3 id="Document-组件与文档加载器详解"><a href="#Document-组件与文档加载器详解" class="headerlink" title="Document 组件与文档加载器详解"></a>Document 组件与文档加载器详解</h3><h4 id="Document-组件基础"><a href="#Document-组件基础" class="headerlink" title="Document 组件基础"></a>Document 组件基础</h4><p>Document 是 LangChain 的核心组件之一，它定义了一个通用的文档结构，包含两个基本要素：</p><pre class="line-numbers language-language-python"><code class="language-language-python">Document = page_content(页面内容) + metadata(元数据)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种结构允许我们统一处理各种类型的文档，同时保留文档的元信息。</p><h4 id="文档加载器类型"><a href="#文档加载器类型" class="headerlink" title="文档加载器类型"></a>文档加载器类型</h4><p>LangChain 提供了多种文档加载器：</p><ol><li>通用文本加载器</li><li>CSV文件加载器</li><li>HTML网页加载器</li><li>PDF文档加载器</li><li>Markdown文档加载器</li></ol><p><img src="/medias/featureimages/blog/langchain-rag-ying-yong-kai-fa-zu-jian-shen-du-jie-xi/image1.png" alt="image"></p><p>每种加载器都专门处理特定类型的文档，但它们都会将文档转换成统一的Document格式。</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_community.document_loaders import TextLoader# 加载文本文件示例loader = TextLoader("./data.txt", encoding="utf-8")documents = loader.load()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异步加载支持"><a href="#异步加载支持" class="headerlink" title="异步加载支持"></a>异步加载支持</h4><p>对于大型文档，LangChain提供了异步加载方式：</p><pre class="line-numbers language-language-python"><code class="language-language-python">async def load_documents():    async with aiofiles.open(file_path, encoding="utf-8") as f:        # 异步处理文档        yield Document(            page_content=line,            metadata=&#123;"source": file_path&#125;        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文档转换器与分割器"><a href="#文档转换器与分割器" class="headerlink" title="文档转换器与分割器"></a>文档转换器与分割器</h3><h4 id="DocumentTransformer-组件"><a href="#DocumentTransformer-组件" class="headerlink" title="DocumentTransformer 组件"></a>DocumentTransformer 组件</h4><p>文档转换器用于处理以下常见问题：</p><ol><li>文档太大导致的性能问题</li><li>原始文档格式不符合要求</li><li>文档内容需要标准化处理</li></ol><h4 id="文档转换器的工作原理"><a href="#文档转换器的工作原理" class="headerlink" title="文档转换器的工作原理"></a>文档转换器的工作原理</h4><p>DocumentTransformer组件的主要职责是对文档进行各种转换操作，包括：</p><ol><li>文档切割</li><li>文档层级提取</li><li>文档翻译</li><li>HTML标签处理</li><li>重排等多个功能</li></ol><p>在LangChain中，所有文档转换器都继承自BaseDocumentTransformer基类，它提供了两个核心方法：</p><pre class="line-numbers language-language-python"><code class="language-language-python">class BaseDocumentTransformer:    def transform_documents(self):         # 转换文档列表        pass            async def atransform_documents(self):        # 异步转换处理        pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文档分割器详解"><a href="#文档分割器详解" class="headerlink" title="文档分割器详解"></a>文档分割器详解</h3><h4 id="字符分割器（CharacterTextSplitter）"><a href="#字符分割器（CharacterTextSplitter）" class="headerlink" title="字符分割器（CharacterTextSplitter）"></a>字符分割器（CharacterTextSplitter）</h4><p>CharacterTextSplitter 是基础的分割器，它有以下重要参数：</p><ol><li><code>separator</code>: 分割符,默认为’\n\n’</li><li><code>chunk_size</code>: 每块文本的最大大小,默认4000</li><li><code>chunk_overlap</code>: 块与块之间的重叠大小,默认200</li><li><code>length_function</code>: 计算文本长度的函数,默认len</li><li><code>keep_separator</code>: 是否在分割的块中保留分隔符</li></ol><p>使用示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_text_splitters import CharacterTextSplittertext_splitter = CharacterTextSplitter(    separator="\n\n",    chunk_size=500,    chunk_overlap=50,    add_start_index=True)# 使用分割器处理文档splits = text_splitter.split_documents(documents)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h4><p>在实际应用中，有以下几点建议：</p><ol><li>选择合适的chunk_size<ul><li>太大会影响处理效率</li><li>太小可能破坏语义完整性</li><li>建议根据实际需求在400-1000之间调整</li></ul></li><li>合理设置overlap<ul><li>设置适当的重叠可以保持上下文连贯</li><li>通常设置为chunk_size的10%-20%</li></ul></li><li>注意分隔符的选择<ul><li>根据文档类型选择合适的分隔符</li><li>可以使用多级分隔符策略</li></ul></li></ol><h3 id="VectorStore组件与检索器"><a href="#VectorStore组件与检索器" class="headerlink" title="VectorStore组件与检索器"></a>VectorStore组件与检索器</h3><h4 id="VectorStore基础概念"><a href="#VectorStore基础概念" class="headerlink" title="VectorStore基础概念"></a>VectorStore基础概念</h4><p>VectorStore组件负责：</p><ol><li>存储文档的向量表示</li><li>提供相似性检索功能</li><li>支持不同的向量检索策略</li></ol><h4 id="检索器的使用"><a href="#检索器的使用" class="headerlink" title="检索器的使用"></a>检索器的使用</h4><p>LangChain 提供了多种检索策略：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain import VectorStore# 基础相似性检索results = vectorstore.similarity_search(query)# 带相似度分数的检索results = vectorstore.similarity_search_with_score(query)# MMR检索策略results = vectorstore.max_marginal_relevance_search(query)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="VectorStore实现细节"><a href="#VectorStore实现细节" class="headerlink" title="VectorStore实现细节"></a>VectorStore实现细节</h3><h4 id="支持的向量数据库"><a href="#支持的向量数据库" class="headerlink" title="支持的向量数据库"></a>支持的向量数据库</h4><ul><li>Chroma</li><li>FAISS</li><li>Pinecone</li><li>Milvus</li></ul><h4 id="检索策略详解"><a href="#检索策略详解" class="headerlink" title="检索策略详解"></a>检索策略详解</h4><ol><li>相似度检索(Similarity Search)<ul><li>基于余弦相似度</li><li>支持Top-K检索</li></ul></li><li>MMR检索(Maximum Marginal Relevance)<ul><li>平衡相关性和多样性</li><li>可配置lambda参数调整权重</li></ul></li><li>混合检索策略<ul><li>关键词+语义检索</li><li>支持自定义评分函数</li></ul></li></ol><h3 id="Blob与BlobParser组件"><a href="#Blob与BlobParser组件" class="headerlink" title="Blob与BlobParser组件"></a>Blob与BlobParser组件</h3><h4 id="Blob方案介绍"><a href="#Blob方案介绍" class="headerlink" title="Blob方案介绍"></a>Blob方案介绍</h4><p>Blob是LangChain处理二进制数据的解决方案，它具有以下特点：</p><ol><li>支持存储字节流数据</li><li>提供统一的数据访问接口</li><li>灵活的元数据管理</li></ol><p>基本使用示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.document_loaders import Blobfrom langchain_core.document_loaders.base import BaseBlobParser# 创建Blob对象blob = Blob.from_path("./data.txt")# 使用解析器parser = CustomParser()documents = list(parser.lazy_parse(blob))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Blob数据存储类详解"><a href="#Blob数据存储类详解" class="headerlink" title="Blob数据存储类详解"></a>Blob数据存储类详解</h4><p>LangChain中的Blob数据存储提供了丰富的属性和方法，让我们详细了解一下：</p><p>核心属性</p><ol><li><strong>data</strong>: 原始数据，支持存储字节，字符串数据</li><li><strong>mimetype</strong>: 文件的mimetype类型</li><li><strong>encoding</strong>: 文件的编码，默认utf-8</li><li><strong>path</strong>: 文件的原始路径</li><li><strong>metadata</strong>: 存储的元数据，通常包含source字段</li></ol><p>常用方法</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 字符串转换as_string(): # 将数据转换为字符串# 字节转换as_bytes(): # 将数据转换为字节数据# 字节流操作as_bytes_io(): # 将数据转换为字节流# 从路径加载from_path(): # 从文件路径加载Blob数据# 从原始数据加载from_data(): # 从原始数据加载Blob数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="BlobLoader实现"><a href="#BlobLoader实现" class="headerlink" title="BlobLoader实现"></a>BlobLoader实现</h4><p>BlobLoader是一个抽象接口，用于实现二进制数据的加载。以下是一个自定义BlobLoader的示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_core.document_loaders import Blobfrom langchain_core.document_loaders.base import BaseBlobParserclass CustomBlobLoader(ABC):    """自定义Blob加载器实现"""        @abstractmethod    def yield_blobs(        self,    ) -> Iterable[Blob]:        """加载并返回Blob数据流"""            def __init__(self, file_path: str):        self.file_path = file_path            def lazy_load(self):        """延迟加载实现"""        for blob in self.yield_blobs():            yield Document(                page_content=blob.as_string(),                metadata=&#123;"source": blob.source&#125;            )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通用加载器使用最佳实践"><a href="#通用加载器使用最佳实践" class="headerlink" title="通用加载器使用最佳实践"></a>通用加载器使用最佳实践</h4><p>GenericLoader是LangChain提供的一个通用加载器，它结合了BlobLoader和BaseBlobParser的功能：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from langchain_community.document_loaders.generic import GenericLoader# 创建通用加载器loader = GenericLoader.from_filesystem(    "./",  # 文件系统路径    glob="*.txt",  # 文件匹配模式    show_progress=True  # 显示进度)# 使用加载器for idx, doc in enumerate(loader.lazy_load()):    print(f"当前加载第&#123;idx + 1&#125;个文件, 文件信息:&#123;doc.metadata&#125;")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h4><ol><li>使用延迟加载<ul><li>对于大文件优先使用lazy_load()</li><li>避免一次性加载全部内容</li></ul></li><li>合理配置缓存<ul><li>利用缓存减少重复加载</li><li>及时清理不需要的缓存</li></ul></li><li>错误处理<ul><li>实现适当的错误处理机制</li><li>记录加载过程中的异常</li></ul></li><li>进度监控<ul><li>对大规模数据处理添加进度显示</li><li>实现断点续传机制</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Langchain </tag>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 命令完整笔记</title>
      <link href="/2024/08/23/git-bi-ji/"/>
      <url>/2024/08/23/git-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git-配置"><a href="#一、Git-配置" class="headerlink" title="一、Git 配置"></a>一、Git 配置</h2><ol><li><p><strong>配置用户信息</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git config --global user.name "Your Name"git config --global user.email "your.email@example.com"# 查看配置git config --listgit config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>配置别名</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.lg "log --oneline --graph --decorate"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>配置编辑器和工具</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git config --global core.editor "vim"git config --global merge.tool vimdiffgit config --global diff.tool vimdiff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="二、基础操作"><a href="#二、基础操作" class="headerlink" title="二、基础操作"></a>二、基础操作</h2><ol><li><p><strong>初始化仓库</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git init                    # 在当前目录初始化git init my-project        # 创建目录并初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>克隆仓库</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git clone https://github.com/user/repo.gitgit clone -b develop https://github.com/user/repo.git    # 克隆特定分支git clone --depth 1 https://github.com/user/repo.git     # 浅克隆，只克隆最新提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看状态</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git status                  # 查看工作区状态git status -s              # 简短输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>添加文件到暂存区</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git add file.txt           # 添加特定文件git add .                  # 添加所有更改git add *.js              # 添加所有JS文件git add -p                 # 交互式添加文件块git add -u                 # 添加已跟踪文件的更改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>提交更改</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git commit -m "Commit message"              # 提交带消息git commit -am "Add and commit message"     # 添加并提交所有更改git commit --amend                          # 修改最后一次提交git commit --amend --no-edit                # 修改但不更改提交信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="三、远程仓库操作"><a href="#三、远程仓库操作" class="headerlink" title="三、远程仓库操作"></a>三、远程仓库操作</h2><ol><li><p><strong>设置远程仓库的URL</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git remote set-url origin https://github.com/your-username/xiaohub.gitgit remote add upstream https://github.com/original/repo.git    # 添加上游仓库git remote -v                                                   # 查看远程仓库git remote show origin                                          # 查看远程仓库详情git remote rename origin old-origin                             # 重命名远程仓库git remote remove old-origin                                    # 删除远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>拉取远程更改</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git fetch origin           # 从远程获取最新，但不合并git pull origin master     # 拉取并合并git pull --rebase         # 拉取并变基<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>推送更改到GitHub</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git push origin master                 # 推送到远程master分支git push -u origin feature-branch      # 推送并设置上游git push origin --tags                 # 推送所有标签git push origin v1.0.0                 # 推送特定标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>强制推送到远程仓库</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git push origin --force --all          # 强制推送所有分支git push origin --force master         # 强制推送特定分支git push --force-with-lease           # 更安全的强制推送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="四、分支管理"><a href="#四、分支管理" class="headerlink" title="四、分支管理"></a>四、分支管理</h2><ol><li><p><strong>创建和切换分支</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git branch                    # 查看本地分支git branch -a                 # 查看所有分支（包括远程）git branch feature-login      # 创建新分支git checkout feature-login    # 切换分支git checkout -b feature-new   # 创建并切换分支git switch -c feature-new     # 新版本创建并切换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>合并分支</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git merge feature-branch      # 合并分支git merge --no-ff feature     # 禁用快进合并git merge --squash feature    # 压缩合并<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>变基操作</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git rebase master            # 变基到mastergit rebase -i HEAD~3         # 交互式变基最近3个提交git rebase --continue        # 解决冲突后继续变基git rebase --abort           # 放弃变基<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>删除分支</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git branch -d feature-branch          # 删除已合并分支git branch -D feature-branch          # 强制删除分支git push origin --delete feature      # 删除远程分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="五、文件管理"><a href="#五、文件管理" class="headerlink" title="五、文件管理"></a>五、文件管理</h2><ol><li><p><strong>从Git仓库中删除文件（可以使用 <code>-f</code>（force）选项来强制移除这些文件的跟踪）</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git rm --cached <file>                # 从索引中删除，保留工作区文件git rm -r --cached <directory>        # 递归删除目录git rm file.txt                       # 删除文件（同时从工作区删除）git rm --cached -r node_modules       # 移除node_modules的跟踪<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>移动或重命名文件</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git mv oldname.txt newname.txt        # 重命名文件git mv file.txt directory/            # 移动文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>.gitignore文件</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 示例.gitignore文件内容*.lognode_modules/.env.DS_Store# 清除已跟踪但现在要忽略的文件git rm -r --cached .git add .git commit -m "Update .gitignore"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="六、提交历史管理"><a href="#六、提交历史管理" class="headerlink" title="六、提交历史管理"></a>六、提交历史管理</h2><ol><li><p><strong>回滚到之前的提交</strong></p><ul><li><p><strong>使用 <code>git reset --hard HEAD^</code></strong>: 这个命令将撤销最后一次提交，并且丢弃所有的更改。请注意，这将彻底删除最后一次提交的所有更改，所以请确保你没有需要保留的其他更改。</p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git reset --hard HEAD^git reset --hard HEAD~2         # 回退2个提交git reset --hard commit-hash    # 回退到特定提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用 <code>git reset --soft HEAD^</code></strong>: 如果你想保留更改但撤销提交，可以使用这个命令。这将把所有的更改放回暂存区，你可以重新编辑并再次提交。</p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git reset --soft HEAD^git reset --soft HEAD~1git reset --mixed HEAD^         # 默认选项，保留工作区更改，重置暂存区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>撤销更改</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git checkout -- file.txt        # 撤销工作区更改git restore file.txt            # 新版本撤销更改git clean -fd                   # 删除未跟踪的文件和目录git clean -n                    # 查看将要删除的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>回滚已推送的提交</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git revert HEAD                 # 创建一个新提交来撤销最后的提交git revert commit-hash          # 撤销特定提交git revert -n HEAD~3..HEAD      # 撤销多个提交但不自动提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="七、查看日志和差异"><a href="#七、查看日志和差异" class="headerlink" title="七、查看日志和差异"></a>七、查看日志和差异</h2><ol><li><p><strong>检查Git历史记录</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git log --all -- <file>              # 查看文件的所有历史git log --graph --oneline --all      # 图形化显示所有分支git log --stat                       # 显示文件修改统计git log --patch                      # 显示具体修改内容git log --author="John"              # 按作者查找提交git log --grep="fix"                 # 按提交信息查找git log --since="2 weeks ago"        # 查看最近两周的提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看最近的提交</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git log -n 10                        # 查看最近10次提交git log --oneline -5                 # 简短格式显示最近5次提交git log --pretty=format:"%h - %an, %ar : %s"   # 自定义格式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看差异</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git diff                             # 查看工作区和暂存区差异git diff --staged                    # 查看暂存区和最新提交差异git diff HEAD                        # 查看工作区和最新提交差异git diff branch1..branch2            # 比较两个分支git diff commit1 commit2             # 比较两个提交git diff --name-only                 # 只显示更改的文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="八、标签管理"><a href="#八、标签管理" class="headerlink" title="八、标签管理"></a>八、标签管理</h2><ol><li><p><strong>创建标签</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git tag v1.0.0                       # 创建轻量标签git tag -a v1.0.0 -m "Version 1.0"   # 创建带注释的标签git tag v1.0.0 commit-hash           # 给特定提交打标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看和管理标签</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git tag                              # 列出所有标签git tag -l "v1.*"                    # 列出匹配的标签git show v1.0.0                      # 查看标签信息git tag -d v1.0.0                    # 删除本地标签git push origin --delete v1.0.0      # 删除远程标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="九、储藏和清理"><a href="#九、储藏和清理" class="headerlink" title="九、储藏和清理"></a>九、储藏和清理</h2><ol><li><p><strong>储藏工作区</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git stash                            # 储藏当前更改git stash save "work in progress"    # 带描述的储藏git stash list                       # 列出所有储藏git stash pop                        # 应用并删除最新储藏git stash apply stash@&#123;2&#125;            # 应用特定储藏git stash drop stash@&#123;1&#125;             # 删除特定储藏git stash clear                      # 清空所有储藏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>清理工作区</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git clean -n                         # 查看将被清理的文件git clean -f                         # 清理未跟踪文件git clean -fd                        # 清理文件和目录git clean -xfd                       # 清理包括.gitignore忽略的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十、查找和调试"><a href="#十、查找和调试" class="headerlink" title="十、查找和调试"></a>十、查找和调试</h2><ol><li><p><strong>定位Bug引入</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git bisect start                     # 开始二分查找git bisect bad                       # 标记当前提交为有buggit bisect good commit-hash          # 标记某个提交为正常git bisect reset                     # 结束查找<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看文件每行最后修改</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git blame file.txt                   # 查看文件每行的最后修改信息git blame -L 10,20 file.txt         # 查看特定行范围<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="十一、Git工作流"><a href="#十一、Git工作流" class="headerlink" title="十一、Git工作流"></a>十一、Git工作流</h2><ol><li><p><strong>特性分支工作流</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 创建特性分支git checkout -b feature/login# 开发完成后git add .git commit -m "Add login feature"# 更新主分支git checkout mastergit pull origin master# 合并特性分支git merge --no-ff feature/logingit push origin master# 删除特性分支git branch -d feature/login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>GitFlow工作流</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 创建开发分支git checkout -b develop master# 创建功能分支git checkout -b feature/login develop# 完成功能分支git checkout developgit merge --no-ff feature/logingit branch -d feature/login# 创建发布分支git checkout -b release/1.0.0 develop# 完成发布git checkout mastergit merge --no-ff release/1.0.0git tag -a v1.0.0git checkout developgit merge --no-ff release/1.0.0git branch -d release/1.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十二、高级操作"><a href="#十二、高级操作" class="headerlink" title="十二、高级操作"></a>十二、高级操作</h2><ol><li><p><strong>子模块管理</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git submodule add https://github.com/user/repo.git path/to/submodulegit submodule initgit submodule updategit submodule update --remotegit submodule foreach git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>获取指定文件版本</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git show HEAD:file.txt               # 查看最新版本文件git show branch:file.txt             # 查看特定分支文件git checkout commit-hash -- file.txt  # 恢复特定版本文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>导出归档</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git archive --format=zip HEAD > archive.zipgit archive --format=tar.gz --prefix=project/ v1.0.0 > project.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="十三、常见问题解决"><a href="#十三、常见问题解决" class="headerlink" title="十三、常见问题解决"></a>十三、常见问题解决</h2><ol><li><p><strong>解决合并冲突</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 出现冲突后git status                  # 查看冲突文件# 编辑冲突文件git add resolved-file.txtgit commit -m "Resolve merge conflict"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>修改历史提交</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 修改最近N个提交git rebase -i HEAD~3# 在编辑器中将pick改为edit, reword, squash等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>找回丢失的提交</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">git reflog                   # 查看所有操作记录git checkout commit-hash     # 恢复到特定提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="十四、Git别名和快捷命令"><a href="#十四、Git别名和快捷命令" class="headerlink" title="十四、Git别名和快捷命令"></a>十四、Git别名和快捷命令</h2><ol><li><strong>常用别名设置</strong><pre class="line-numbers language-language-bash"><code class="language-language-bash">git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage 'reset HEAD --'git config --global alias.last 'log -1 HEAD'git config --global alias.visual '!gitk'git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十五、Git最佳实践"><a href="#十五、Git最佳实践" class="headerlink" title="十五、Git最佳实践"></a>十五、Git最佳实践</h2><ol><li><p><strong>提交信息规范</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 好的提交信息feat: 添加用户登录功能fix: 修复导航栏在移动端显示异常docs: 更新README文件style: 格式化代码refactor: 重构用户模块test: 添加用户登录单元测试chore: 更新依赖版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>保持提交原子性</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 每个提交只做一件事git add file1.jsgit commit -m "Add user validation"git add file2.jsgit commit -m "Add password encryption"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>定期推送和拉取</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 每天工作开始git pull origin develop# 完成功能后git push origin feature-branch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2024/08/10/linux-bi-ji/"/>
      <url>/2024/08/10/linux-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、文件与目录操作"><a href="#一、文件与目录操作" class="headerlink" title="一、文件与目录操作"></a>一、文件与目录操作</h2><ol><li><p><strong>列出目录内容</strong></p><ul><li><code>ls</code>：列出当前目录</li><li><code>ls -l</code>：显示详细信息（权限、拥有者、大小、修改时间）</li><li><code>ls -a</code>：包括隐藏文件（<code>.</code> 开头）</li><li><code>ls -lh</code>：人性化显示文件大小（K, M, G）</li><li><code>ls -lt</code>：按修改时间排序，最新在前</li><li><code>ls -lS</code>：按文件大小排序，最大在前</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">ls -la /etc          # 列出 /etc 目录的所有文件（包括隐藏文件）ls -lh ~/Downloads   # 显示下载目录文件，以人性化方式显示大小ls -lt *.log         # 按时间排序显示所有日志文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>目录切换与查看</strong></p><ul><li><code>pwd</code>：显示当前所在目录的完整路径</li><li><code>cd 目录</code>：切换目录</li><li><code>cd ..</code>：返回上级目录</li><li><code>cd -</code>：返回上次所在目录</li><li><code>cd ~</code>：切换到用户主目录</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">pwd                  # 显示当前工作目录cd /var/log          # 切换到系统日志目录cd ../..             # 返回上两级目录cd -                 # 快速返回上一个访问的目录cd ~/Documents       # 切换到用户文档目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复制&#x2F;移动&#x2F;删除</strong></p><ul><li><code>cp 源 目标</code>：复制文件或目录（加 <code>-r</code> 递归）</li><li><code>cp -i</code>：覆盖前询问</li><li><code>cp -p</code>：保留源文件属性（时间戳、权限等）</li><li><code>mv 源 目标</code>：移动或重命名</li><li><code>mv -i</code>：覆盖前询问</li><li><code>rm 文件</code>：删除文件；<code>rm -r 目录</code>：递归删除目录</li><li><code>rm -i</code>：删除前询问确认</li><li><code>rm -f</code>：强制删除，不询问</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">cp file1.txt file2.txt              # 复制文件cp -r dir1/ dir2/                   # 递归复制目录cp -ip old.conf new.conf            # 复制文件并保留属性，覆盖前询问mv oldname.txt newname.txt          # 重命名文件mv *.jpg ~/Pictures/                # 移动所有图片到目录rm -rf temp/                        # 强制删除目录及内容（慎用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>创建文件与目录</strong></p><ul><li><code>mkdir 目录名</code>：创建目录</li><li><code>mkdir -p 路径/目录</code>：创建多级目录</li><li><code>touch 文件名</code>：创建空文件或更新时间戳</li><li><code>rmdir 目录名</code>：删除空目录</li><li><code>tree</code>：以树状图显示目录结构（若未安装可 <code>sudo apt install tree</code>）</li></ul></li><li><p><strong>链接操作</strong></p><ul><li><code>ln -s 源文件 软链接</code>：创建软链接（符号链接）</li><li><code>ln 源文件 硬链接</code>：创建硬链接</li><li><code>readlink 链接</code>：查看链接指向的实际路径</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">ln -s /usr/bin/python3 ~/bin/python           # 创建 Python 软链接ln important.txt backup_hard_link.txt         # 创建硬链接readlink /bin/sh                              # 查看链接指向的实际文件ls -l /bin | grep '^l'                        # 查看所有符号链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看文件内容</strong></p><ul><li><code>cat 文件</code>：一次性显示全文</li><li><code>cat -n</code>：显示行号</li><li><code>more/less 文件</code>：分页查看，<code>/ + 关键字</code> 搜索，<code>n</code> 跳到下一个匹配</li><li><code>head -n 10 文件</code>：查看前 10 行；<code>tail -n 10 文件</code>：后 10 行</li><li><code>tail -f 文件</code>：实时追踪文件新增内容，常用于日志监控</li><li><code>file 文件</code>：查看文件类型</li></ul></li></ol><hr><h2 id="二、文本处理与过滤"><a href="#二、文本处理与过滤" class="headerlink" title="二、文本处理与过滤"></a>二、文本处理与过滤</h2><ol><li><p><strong>过滤与查找</strong></p><ul><li><code>grep 模式 文件</code>：查找匹配行；<code>-i</code> 忽略大小写；<code>-n</code> 显示行号；<code>-v</code> 反向查找</li><li><code>grep -r 模式 目录</code>：递归搜索目录</li><li><code>grep -E &#39;正则表达式&#39;</code>：使用扩展正则表达式</li><li><code>egrep</code>：等同于 <code>grep -E</code></li><li><code>awk &#39;&#123;print $1,$3&#125;&#39; 文件</code>：按空格分列，打印第 1、3 列</li><li><code>cut -d&#39;:&#39; -f1 /etc/passwd</code>：以 <code>:</code> 分割，取第一列</li><li><code>sed &#39;s/old/new/g&#39; 文件</code>：替换（默认只输出到标准输出）；加 <code>-i</code> 直接修改文件</li><li><code>sed -n &#39;1,10p&#39; 文件</code>：只显示第 1-10 行</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">grep -n "ERROR" server.log                    # 查找错误日志，显示行号grep -r "TODO" ./src                          # 递归搜索源代码中的 TODOgrep -E '^[0-9]&#123;3&#125;-[0-9]&#123;4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>排序与去重</strong></p><ul><li><code>sort 文件</code>：排序；<code>sort -n</code> 数值排序；<code>-r</code> 逆序；<code>-k n</code> 指定第 n 列排序</li><li><code>uniq 文件</code>：去除相邻重复；<code>uniq -c</code> 统计次数；常与 <code>sort</code> 管道配合：<pre class="line-numbers language-language-bash"><code class="language-language-bash">sort abc.txt | uniq -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>comm 文件1 文件2</code>：比较两个已排序文件的异同</li></ul></li><li><p><strong>统计与比较</strong></p><ul><li><code>wc -l 文件</code>：统计行数；<code>-m</code> 字符数；<code>-c</code> 字节数；<code>-L</code> 最长行长度；<code>-w</code> 单词数</li><li><code>diff 文件1 文件2</code>：比较文件差异</li><li><code>diff -u</code>：以统一格式显示差异</li><li><code>cmp 文件1 文件2</code>：二进制比较文件</li></ul></li><li><p><strong>字符转换</strong></p><ul><li><code>tr &#39;a-z&#39; &#39;A-Z&#39; &lt; 文件</code>：小写转大写</li><li><code>tr -d &#39;0-9&#39;</code>：删除所有数字</li><li><code>tr -s &#39; &#39;</code>：压缩连续空格为单个空格</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">echo "hello world" | tr 'a-z' 'A-Z'          # 转换为大写: HELLO WORLDecho "user123pass456" | tr -d '0-9'          # 删除数字: userpassecho "too    many    spaces" | tr -s ' '      # 压缩空格: too many spacescat file.txt | tr '\n' ' '                    # 将换行符替换为空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="三、权限与拥有者"><a href="#三、权限与拥有者" class="headerlink" title="三、权限与拥有者"></a>三、权限与拥有者</h2><ol><li><p><strong>查看权限</strong></p><ul><li><code>ls -l</code> 第一列如 <code>-rwxr-xr--</code>：分别是文件类型、用户&#x2F;组&#x2F;其他用户的读(r)&#x2F;写(w)&#x2F;执行(x) 权限</li><li><code>stat 文件</code>：查看文件详细状态信息</li></ul></li><li><p><strong>修改权限</strong></p><ul><li><code>chmod u+rw 文件</code>：用户添加读写权限；也可用数字模式，如 <code>chmod 755 文件</code></li><li><code>chmod g-w 文件</code>：组移除写权限</li><li><code>chmod o+x 文件</code>：其他用户添加执行权限</li><li><code>chmod -R 755 目录</code>：递归修改目录及子目录权限</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">chmod 644 file.txt                   # 设置 rw-r--r-- 权限chmod u+x script.sh                  # 给所有者添加执行权限chmod -R 755 /var/www/html          # 递归设置 web 目录权限chmod a-x sensitive.dat             # 移除所有用户的执行权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>修改拥有者&#x2F;所属组</strong></p><ul><li><code>chown user:group 文件</code>：同时修改用户与组</li><li><code>chown user 文件</code> 或 <code>chown :group 文件</code></li><li><code>chown -R user:group 目录</code>：递归修改目录权限</li></ul></li><li><p><strong>特殊权限</strong></p><ul><li><code>chmod u+s 文件</code>：设置 SUID 权限</li><li><code>chmod g+s 目录</code>：设置 SGID 权限</li><li><code>chmod +t 目录</code>：设置粘滞位</li><li><code>umask</code>：查看默认权限掩码</li><li><code>umask 022</code>：设置默认权限掩码</li></ul></li><li><p><strong>文件属性</strong></p><ul><li><code>lsattr 文件</code>：查看文件特殊属性</li><li><code>chattr +i 文件</code>：设置不可修改属性</li><li><code>chattr +a 文件</code>：设置只能追加属性</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">chattr +i /etc/resolv.conf           # 防止文件被修改chattr +a /var/log/secure           # 只允许追加内容lsattr /etc/resolv.conf             # 查看文件属性chattr -i /etc/resolv.conf          # 移除不可修改属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="四、进程与作业管理"><a href="#四、进程与作业管理" class="headerlink" title="四、进程与作业管理"></a>四、进程与作业管理</h2><ol><li><p><strong>查看进程</strong></p><ul><li><code>ps -ef</code>：列出所有进程；常与 <code>grep</code> 结合过滤</li><li><code>ps aux</code>：显示详细进程信息</li><li><code>pstree</code>：以树状图显示进程关系</li><li><code>top</code> &#x2F; <code>htop</code>：动态监控 CPU&#x2F;内存&#x2F;进程（按 q 退出）</li><li><code>pgrep 进程名</code>：按名称查找进程 ID</li></ul></li><li><p><strong>杀死进程</strong></p><ul><li><code>kill PID</code>：温和终止（发送 SIGTERM 信号）</li><li><code>kill -9 PID</code>：强制终止（发送 SIGKILL 信号）</li><li><code>kill -l</code>：列出所有信号</li><li><code>pkill 进程名</code> &#x2F; <code>killall 进程名</code>：按名杀死</li><li><code>killall -u 用户名</code>：杀死指定用户的所有进程</li></ul></li><li><p><strong>进程优先级</strong></p><ul><li><code>nice -n 10 命令</code>：以较低优先级运行命令</li><li><code>renice +10 -p PID</code>：调整运行中进程的优先级</li></ul></li><li><p><strong>后台与作业控制</strong></p><ul><li><code>command &amp;</code>：后台运行</li><li><code>jobs</code>：查看后台作业，<code>fg %1</code> 将第 1 个作业拉到前台，<code>bg %1</code> 让其后台运行</li><li><code>nohup command &amp;</code>：后台运行且忽略挂断信号（退出终端后继续运行）</li><li><code>Ctrl+Z</code>：挂起当前进程</li><li><code>Ctrl+C</code>：终止当前进程</li></ul></li></ol><hr><h2 id="五、网络与远程操作"><a href="#五、网络与远程操作" class="headerlink" title="五、网络与远程操作"></a>五、网络与远程操作</h2><ol><li><p><strong>网络诊断</strong></p><ul><li><code>ping 主机</code>：连通性测试</li><li><code>ping -c 4</code>：只发送 4 个数据包</li><li><code>traceroute 主机</code>：路由追踪</li><li><code>mtr 主机</code>：结合 ping 和 traceroute 功能</li><li><code>netstat -anp</code>：查看端口、连接；常与 <code>grep</code> 结合</li><li><code>ss -tulnp</code>：更现代的端口查看工具</li><li><code>nmap 主机</code>：端口扫描（需要安装）</li></ul></li><li><p><strong>DNS 查询</strong></p><ul><li><code>nslookup 域名</code>：查询 DNS 记录</li><li><code>dig 域名</code>：详细 DNS 查询</li><li><code>host 域名</code>：简单 DNS 查询</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">nslookup google.com                  # 查询域名的 IP 地址dig @8.8.8.8 example.com            # 使用指定 DNS 服务器查询dig example.com MX                   # 查询邮件服务器记录host -t AAAA ipv6.google.com        # 查询 IPv6 地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>网络配置</strong></p><ul><li><code>ifconfig</code>：查看网络接口（较旧）</li><li><code>ip addr show</code>：查看 IP 地址（现代替代 ifconfig）</li><li><code>ip route show</code>：查看路由表</li><li><code>hostname</code>：显示主机名</li><li><code>hostname -I</code>：显示所有 IP 地址</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">ip addr show eth0                    # 显示特定网卡信息ip route add 192.168.1.0/24 via 192.168.1.1  # 添加静态路由ip link set eth0 up                  # 启用网卡ifconfig eth0 192.168.1.100         # 设置 IP 地址（旧方式）sudo hostnamectl set-hostname newname  # 修改主机名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>文件传输与远程登录</strong></p><ul><li><code>ssh user@host</code>：远程登录</li><li><code>ssh -p 端口 user@host</code>：指定端口登录</li><li><code>scp 本地 远端</code> &#x2F; <code>scp user@host:远端 本地</code>：安全复制</li><li><code>sftp user@host</code>：安全文件传输</li><li><code>rsync -avz 源 目标</code>：增量同步</li><li><code>rsync -avz --delete 源 目标</code>：同步并删除目标中源没有的文件</li></ul></li><li><p><strong>下载工具</strong></p><ul><li><code>wget URL</code>：下载文件</li><li><code>wget -c URL</code>：断点续传</li><li><code>curl URL</code>：发送网络请求</li><li><code>curl -O URL</code>：下载文件</li><li><code>curl -H &quot;Header: Value&quot; URL</code>：添加请求头</li></ul></li><li><p><strong>查看公网 IP</strong></p><ul><li><code>curl -4 ifconfig.co</code> 或 <code>curl ipinfo.io/ip</code></li><li><code>curl icanhazip.com</code></li></ul></li></ol><hr><h2 id="六、磁盘与存储"><a href="#六、磁盘与存储" class="headerlink" title="六、磁盘与存储"></a>六、磁盘与存储</h2><ol><li><p><strong>磁盘使用情况</strong></p><ul><li><code>df -h</code>：查看各分区总量与剩余空间</li><li><code>df -i</code>：查看 inode 使用情况</li><li><code>du -sh 目录</code>：查看目录总占用；<code>du -h --max-depth=1</code> 查看子目录分布</li><li><code>du -h | sort -h</code>：按大小排序显示</li><li><code>ncdu</code>：交互式磁盘使用分析（需要安装）</li></ul></li><li><p><strong>块设备管理</strong></p><ul><li><code>lsblk</code>：列出块设备信息</li><li><code>blkid</code>：显示块设备属性</li><li><code>fdisk -l</code>：列出磁盘分区信息</li><li><code>parted -l</code>：列出分区信息（支持 GPT）</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">lsblk -f                             # 显示文件系统类型blkid /dev/sda1                      # 显示分区 UUID 和类型sudo fdisk -l /dev/sda               # 查看磁盘分区表sudo parted /dev/sda print           # 显示分区信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>文件系统操作</strong></p><ul><li><code>mount 设备 挂载点</code>：挂载文件系统</li><li><code>umount 设备/挂载点</code>：卸载文件系统</li><li><code>mount -o remount,rw /</code>：重新挂载为读写模式</li><li><code>fsck 设备</code>：文件系统检查和修复</li><li><code>mkfs.ext4 设备</code>：创建 ext4 文件系统</li></ul></li><li><p><strong>打包压缩</strong></p><ul><li><code>tar -czvf archive.tar.gz 目录/文件</code>：打包并 gzip 压缩</li><li><code>tar -xzvf archive.tar.gz</code>：解压</li><li><code>tar -tf archive.tar</code>：查看压缩包内容而不解压</li><li><code>zip -r archive.zip 目录</code> &#x2F; <code>unzip archive.zip</code></li><li><code>gzip 文件</code> &#x2F; <code>gunzip 文件.gz</code></li><li><code>bzip2 文件</code> &#x2F; <code>bunzip2 文件.bz2</code></li><li><code>xz 文件</code> &#x2F; <code>unxz 文件.xz</code></li></ul></li><li><p><strong>数据复制与备份</strong></p><ul><li><code>dd if=源 of=目标 bs=块大小</code>：数据复制</li><li><code>dd if=/dev/zero of=file bs=1M count=100</code>：创建100M空文件</li><li><code>cp --sparse=always 文件 目标</code>：复制稀疏文件</li></ul></li></ol><hr><h2 id="七、查找与批处理"><a href="#七、查找与批处理" class="headerlink" title="七、查找与批处理"></a>七、查找与批处理</h2><ol><li><p><strong>查找文件</strong></p><ul><li><code>find . -name &#39;*.log&#39;</code>：当前目录及子目录查找</li><li><code>find /path -type f -mtime -7</code>：查找 7 天内修改的文件</li><li><code>find . -type f -name &#39;xiaohub.log.2024-06*&#39; -delete</code>：批量删除</li><li><code>find . -size +100M</code>：查找大于 100M 的文件</li><li><code>find . -empty</code>：查找空文件或空目录</li><li><code>find . -perm 777</code>：查找权限为 777 的文件</li></ul></li><li><p><strong>快速定位</strong></p><ul><li><code>locate 文件名</code>：快速查找文件（基于数据库）</li><li><code>updatedb</code>：更新 locate 数据库</li><li><code>which 命令</code>：查找命令的完整路径</li><li><code>whereis 命令</code>：查找二进制、源代码和手册页位置</li><li><code>type 命令</code>：显示命令类型（别名、内置、外部命令）</li></ul></li><li><p><strong>批量执行</strong></p><ul><li>与 <code>find</code> + <code>-exec</code>：<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.sh' -exec chmod +x &#123;&#125; \;find /var/log -name '*.log' -exec cp &#123;&#125; &#123;&#125;.bak \;find . -type f -exec md5sum &#123;&#125; \; > checksums.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><code>xargs</code>：<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.txt' | xargs grep '关键字'find . -name '*.tmp' | xargs rm -fls *.jpg | xargs -I &#123;&#125; convert &#123;&#125; &#123;&#125;.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><code>parallel</code>：并行执行命令（需要安装）<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.jpg' | parallel convert &#123;&#125; &#123;.&#125;.pngcat urls.txt | parallel wget &#123;&#125;seq 1 10 | parallel -j4 'echo "Process &#123;&#125;"'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><hr><h2 id="八、Shell-环境与脚本"><a href="#八、Shell-环境与脚本" class="headerlink" title="八、Shell 环境与脚本"></a>八、Shell 环境与脚本</h2><ol><li><p><strong>环境变量</strong></p><ul><li><code>export VAR=value</code>：临时设置；写入 <code>~/.bashrc</code> 或 <code>~/.profile</code> 实现持久</li><li><code>echo $VAR</code>：显示变量值</li><li><code>env</code>：显示所有环境变量</li><li><code>set</code>：显示所有变量（包括局部变量）</li><li><code>unset VAR</code>：删除变量</li><li><code>source 文件</code> 或 <code>.</code>：重新加载配置</li></ul></li><li><p><strong>Shell 配置</strong></p><ul><li><code>~/.bashrc</code>：bash shell 配置文件</li><li><code>~/.bash_profile</code>：登录 shell 配置文件</li><li><code>~/.bash_history</code>：命令历史记录</li></ul></li><li><p><strong>常见提示</strong></p><ul><li><code>history</code>：查看历史命令；<code>!n</code> 重复第 n 条，<code>!!</code> 重复上一条</li><li><code>history -c</code>：清除历史记录</li><li><code>Ctrl+R</code>：反向搜索历史命令</li><li>Tab 自动补全</li><li><code>alias ll=&#39;ls -l&#39;</code>：自定义快捷命令，写入 <code>~/.bashrc</code> 生效</li><li><code>unalias 别名</code>：删除别名</li></ul></li><li><p><strong>目录操作</strong></p><ul><li><code>pushd 目录</code>：将目录压入堆栈并切换</li><li><code>popd</code>：从堆栈弹出目录并切换</li><li><code>dirs</code>：显示目录堆栈</li></ul></li><li><p><strong>脚本规范</strong></p><ul><li>首行 <code>#!/bin/bash</code> 或 <code>#!/usr/bin/env bash</code></li><li>脚本执行前加执行权限：<code>chmod +x script.sh</code></li><li>参数获取：<code>$1,$2,…</code>；循环 <code>for arg in &quot;$@&quot;; do …; done</code></li><li><code>$0</code>：脚本名称</li><li><code>$#</code>：参数个数</li><li><code>$?</code>：上个命令的退出状态</li><li><code>test</code> 或 <code>[ ]</code>：条件测试</li><li><code>[[ ]]</code>：扩展的条件测试（支持正则）</li></ul></li></ol><hr><h2 id="九、系统管理"><a href="#九、系统管理" class="headerlink" title="九、系统管理"></a>九、系统管理</h2><ol><li><p><strong>服务与日志</strong></p><ul><li><code>systemctl status 服务名</code>：查看服务状态</li><li><code>systemctl start/stop/restart 服务名</code>：启停服务</li><li><code>systemctl enable/disable 服务名</code>：开机自启设置</li><li><code>journalctl -u 服务名</code>：查看 systemd 日志</li><li><code>journalctl -f</code>：实时查看系统日志</li></ul></li><li><p><strong>定时任务</strong></p><ul><li><code>crontab -e</code>：编辑当前用户 crontab</li><li><code>crontab -l</code>：列出当前用户的定时任务</li><li>格式：<code>* * * * * command</code>（分 时 日 月 周）</li><li><code>/etc/crontab</code>：系统级定时任务</li></ul></li><li><p><strong>用户与组管理</strong></p><ul><li><code>useradd 用户名</code> &#x2F; <code>usermod -aG group 用户名</code> &#x2F; <code>userdel 用户名</code></li><li><code>passwd 用户名</code>：设置用户密码</li><li><code>groups 用户名</code>：查看用户所属组</li><li><code>id 用户名</code>：显示用户和组 ID</li><li><code>su - 用户名</code>：切换用户</li><li><code>sudo 命令</code>：以 root 权限执行命令</li></ul></li><li><p><strong>系统监控</strong></p><ul><li><code>free -h</code>：查看内存使用情况</li><li><code>uptime</code>：系统运行时间和负载</li><li><code>dmesg</code>：查看内核消息</li><li><code>lsof</code>：列出打开的文件</li><li><code>lsof -i :端口</code>：查看端口占用情况</li><li><code>vmstat</code>：虚拟内存统计</li><li><code>iostat</code>：IO 统计</li><li><code>sar</code>：系统活动报告（需要安装 sysstat）</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">free -h                              # 显示人性化的内存使用信息uptime                               # 显示运行时间和负载dmesg | tail -20                     # 查看最近的内核消息lsof -i :80                          # 查看 80 端口占用lsof -p 1234                         # 查看进程 1234 打开的文件vmstat 2 5                           # 每 2 秒更新一次，共 5 次iostat -x 1                          # 每秒显示详细 IO 统计sar -u 1 5                           # CPU 使用率，每秒更新，共 5 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="十、软件包管理"><a href="#十、软件包管理" class="headerlink" title="十、软件包管理"></a>十、软件包管理</h2><ol><li><p><strong>Debian&#x2F;Ubuntu（APT）</strong></p><ul><li><code>apt update</code>：更新软件包列表</li><li><code>apt upgrade</code>：升级已安装软件包</li><li><code>apt install 软件包</code>：安装软件</li><li><code>apt remove 软件包</code>：删除软件</li><li><code>apt search 关键字</code>：搜索软件包</li><li><code>apt show 软件包</code>：显示软件包信息</li><li><code>apt autoremove</code>：删除不需要的依赖包</li></ul></li><li><p><strong>RHEL&#x2F;CentOS（YUM&#x2F;DNF）</strong></p><ul><li><code>yum update</code>：更新软件包</li><li><code>yum install 软件包</code>：安装软件</li><li><code>yum remove 软件包</code>：删除软件</li><li><code>yum search 关键字</code>：搜索软件包</li><li><code>yum info 软件包</code>：显示软件包信息</li><li><code>dnf</code>：新版本的 Fedora&#x2F;RHEL 使用 dnf 替代 yum</li></ul></li><li><p><strong>常用工具安装</strong></p><ul><li><code>apt install net-tools</code>：安装传统网络工具（ifconfig 等）</li><li><code>apt install vim</code>：安装 vim 编辑器</li><li><code>apt install htop</code>：安装 htop 进程监控工具</li><li><code>apt install ncdu</code>：安装磁盘使用分析工具</li></ul></li></ol><hr><h2 id="十一、快捷键与技巧"><a href="#十一、快捷键与技巧" class="headerlink" title="十一、快捷键与技巧"></a>十一、快捷键与技巧</h2><ol><li><p><strong>终端快捷键</strong></p><ul><li><code>Ctrl+A</code>：移到行首</li><li><code>Ctrl+E</code>：移到行尾</li><li><code>Ctrl+U</code>：删除光标前的内容</li><li><code>Ctrl+K</code>：删除光标后的内容</li><li><code>Ctrl+W</code>：删除光标前的单词</li><li><code>Ctrl+L</code>：清屏（等同于 clear）</li><li><code>Ctrl+D</code>：退出当前 shell</li></ul></li><li><p><strong>命令行技巧</strong></p><ul><li><code>!!</code>：重复执行上一条命令</li><li>&#96;!## 一、文件与目录操作</li></ul></li><li><p><strong>列出目录内容</strong></p><ul><li><code>ls</code>：列出当前目录</li><li><code>ls -l</code>：显示详细信息（权限、拥有者、大小、修改时间）</li><li><code>ls -a</code>：包括隐藏文件（<code>.</code> 开头）</li><li><code>ls -lh</code>：人性化显示文件大小（K, M, G）</li><li><code>ls -lt</code>：按修改时间排序，最新在前</li><li><code>ls -lS</code>：按文件大小排序，最大在前</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">ls -la /etc          # 列出 /etc 目录的所有文件（包括隐藏文件）ls -lh ~/Downloads   # 显示下载目录文件，以人性化方式显示大小ls -lt *.log         # 按时间排序显示所有日志文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>目录切换与查看</strong></p><ul><li><code>pwd</code>：显示当前所在目录的完整路径</li><li><code>cd 目录</code>：切换目录</li><li><code>cd ..</code>：返回上级目录</li><li><code>cd -</code>：返回上次所在目录</li><li><code>cd ~</code>：切换到用户主目录</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">pwd                  # 显示当前工作目录cd /var/log          # 切换到系统日志目录cd ../..             # 返回上两级目录cd -                 # 快速返回上一个访问的目录cd ~/Documents       # 切换到用户文档目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复制&#x2F;移动&#x2F;删除</strong></p><ul><li><code>cp 源 目标</code>：复制文件或目录（加 <code>-r</code> 递归）</li><li><code>cp -i</code>：覆盖前询问</li><li><code>cp -p</code>：保留源文件属性（时间戳、权限等）</li><li><code>mv 源 目标</code>：移动或重命名</li><li><code>mv -i</code>：覆盖前询问</li><li><code>rm 文件</code>：删除文件；<code>rm -r 目录</code>：递归删除目录</li><li><code>rm -i</code>：删除前询问确认</li><li><code>rm -f</code>：强制删除，不询问</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">cp file1.txt file2.txt              # 复制文件cp -r dir1/ dir2/                   # 递归复制目录cp -ip old.conf new.conf            # 复制文件并保留属性，覆盖前询问mv oldname.txt newname.txt          # 重命名文件mv *.jpg ~/Pictures/                # 移动所有图片到目录rm -rf temp/                        # 强制删除目录及内容（慎用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>创建文件与目录</strong></p><ul><li><code>mkdir 目录名</code>：创建目录</li><li><code>mkdir -p 路径/目录</code>：创建多级目录</li><li><code>touch 文件名</code>：创建空文件或更新时间戳</li><li><code>rmdir 目录名</code>：删除空目录</li><li><code>tree</code>：以树状图显示目录结构（若未安装可 <code>sudo apt install tree</code>）</li></ul></li><li><p><strong>链接操作</strong></p><ul><li><code>ln -s 源文件 软链接</code>：创建软链接（符号链接）</li><li><code>ln 源文件 硬链接</code>：创建硬链接</li><li><code>readlink 链接</code>：查看链接指向的实际路径</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">ln -s /usr/bin/python3 ~/bin/python           # 创建 Python 软链接ln important.txt backup_hard_link.txt         # 创建硬链接readlink /bin/sh                              # 查看链接指向的实际文件ls -l /bin | grep '^l'                        # 查看所有符号链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看文件内容</strong></p><ul><li><code>cat 文件</code>：一次性显示全文</li><li><code>cat -n</code>：显示行号</li><li><code>more/less 文件</code>：分页查看，<code>/ + 关键字</code> 搜索，<code>n</code> 跳到下一个匹配</li><li><code>head -n 10 文件</code>：查看前 10 行；<code>tail -n 10 文件</code>：后 10 行</li><li><code>tail -f 文件</code>：实时追踪文件新增内容，常用于日志监控</li><li><code>file 文件</code>：查看文件类型</li></ul></li></ol><hr><h2 id="二、文本处理与过滤-1"><a href="#二、文本处理与过滤-1" class="headerlink" title="二、文本处理与过滤"></a>二、文本处理与过滤</h2><ol><li><p><strong>过滤与查找</strong></p><ul><li><code>grep 模式 文件</code>：查找匹配行；<code>-i</code> 忽略大小写；<code>-n</code> 显示行号；<code>-v</code> 反向查找</li><li><code>grep -r 模式 目录</code>：递归搜索目录</li><li><code>grep -E &#39;正则表达式&#39;</code>：使用扩展正则表达式</li><li><code>egrep</code>：等同于 <code>grep -E</code></li><li><code>awk &#39;&#123;print $1,$3&#125;&#39; 文件</code>：按空格分列，打印第 1、3 列</li><li><code>cut -d&#39;:&#39; -f1 /etc/passwd</code>：以 <code>:</code> 分割，取第一列</li><li><code>sed &#39;s/old/new/g&#39; 文件</code>：替换（默认只输出到标准输出）；加 <code>-i</code> 直接修改文件</li><li><code>sed -n &#39;1,10p&#39; 文件</code>：只显示第 1-10 行</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">grep -n "ERROR" server.log                    # 查找错误日志，显示行号grep -r "TODO" ./src                          # 递归搜索源代码中的 TODOgrep -E '^[0-9]&#123;3&#125;-[0-9]&#123;4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>排序与去重</strong></p><ul><li><code>sort 文件</code>：排序；<code>sort -n</code> 数值排序；<code>-r</code> 逆序；<code>-k n</code> 指定第 n 列排序</li><li><code>uniq 文件</code>：去除相邻重复；<code>uniq -c</code> 统计次数；常与 <code>sort</code> 管道配合：<pre class="line-numbers language-language-bash"><code class="language-language-bash">sort abc.txt | uniq -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>comm 文件1 文件2</code>：比较两个已排序文件的异同</li></ul></li><li><p><strong>统计与比较</strong></p><ul><li><code>wc -l 文件</code>：统计行数；<code>-m</code> 字符数；<code>-c</code> 字节数；<code>-L</code> 最长行长度；<code>-w</code> 单词数</li><li><code>diff 文件1 文件2</code>：比较文件差异</li><li><code>diff -u</code>：以统一格式显示差异</li><li><code>cmp 文件1 文件2</code>：二进制比较文件</li></ul></li><li><p><strong>字符转换</strong></p><ul><li><code>tr &#39;a-z&#39; &#39;A-Z&#39; &lt; 文件</code>：小写转大写</li><li><code>tr -d &#39;0-9&#39;</code>：删除所有数字</li><li><code>tr -s &#39; &#39;</code>：压缩连续空格为单个空格</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">echo "hello world" | tr 'a-z' 'A-Z'          # 转换为大写: HELLO WORLDecho "user123pass456" | tr -d '0-9'          # 删除数字: userpassecho "too    many    spaces" | tr -s ' '      # 压缩空格: too many spacescat file.txt | tr '\n' ' '                    # 将换行符替换为空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="三、权限与拥有者-1"><a href="#三、权限与拥有者-1" class="headerlink" title="三、权限与拥有者"></a>三、权限与拥有者</h2><ol><li><p><strong>查看权限</strong></p><ul><li><code>ls -l</code> 第一列如 <code>-rwxr-xr--</code>：分别是文件类型、用户&#x2F;组&#x2F;其他用户的读(r)&#x2F;写(w)&#x2F;执行(x) 权限</li><li><code>stat 文件</code>：查看文件详细状态信息</li></ul></li><li><p><strong>修改权限</strong></p><ul><li><code>chmod u+rw 文件</code>：用户添加读写权限；也可用数字模式，如 <code>chmod 755 文件</code></li><li><code>chmod g-w 文件</code>：组移除写权限</li><li><code>chmod o+x 文件</code>：其他用户添加执行权限</li><li><code>chmod -R 755 目录</code>：递归修改目录及子目录权限</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">chmod 644 file.txt                   # 设置 rw-r--r-- 权限chmod u+x script.sh                  # 给所有者添加执行权限chmod -R 755 /var/www/html          # 递归设置 web 目录权限chmod a-x sensitive.dat             # 移除所有用户的执行权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>修改拥有者&#x2F;所属组</strong></p><ul><li><code>chown user:group 文件</code>：同时修改用户与组</li><li><code>chown user 文件</code> 或 <code>chown :group 文件</code></li><li><code>chown -R user:group 目录</code>：递归修改目录权限</li></ul></li><li><p><strong>特殊权限</strong></p><ul><li><code>chmod u+s 文件</code>：设置 SUID 权限</li><li><code>chmod g+s 目录</code>：设置 SGID 权限</li><li><code>chmod +t 目录</code>：设置粘滞位</li><li><code>umask</code>：查看默认权限掩码</li><li><code>umask 022</code>：设置默认权限掩码</li></ul></li><li><p><strong>文件属性</strong></p><ul><li><code>lsattr 文件</code>：查看文件特殊属性</li><li><code>chattr +i 文件</code>：设置不可修改属性</li><li><code>chattr +a 文件</code>：设置只能追加属性</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">chattr +i /etc/resolv.conf           # 防止文件被修改chattr +a /var/log/secure           # 只允许追加内容lsattr /etc/resolv.conf             # 查看文件属性chattr -i /etc/resolv.conf          # 移除不可修改属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="四、进程与作业管理-1"><a href="#四、进程与作业管理-1" class="headerlink" title="四、进程与作业管理"></a>四、进程与作业管理</h2><ol><li><p><strong>查看进程</strong></p><ul><li><code>ps -ef</code>：列出所有进程；常与 <code>grep</code> 结合过滤</li><li><code>ps aux</code>：显示详细进程信息</li><li><code>pstree</code>：以树状图显示进程关系</li><li><code>top</code> &#x2F; <code>htop</code>：动态监控 CPU&#x2F;内存&#x2F;进程（按 q 退出）</li><li><code>pgrep 进程名</code>：按名称查找进程 ID</li></ul></li><li><p><strong>杀死进程</strong></p><ul><li><code>kill PID</code>：温和终止（发送 SIGTERM 信号）</li><li><code>kill -9 PID</code>：强制终止（发送 SIGKILL 信号）</li><li><code>kill -l</code>：列出所有信号</li><li><code>pkill 进程名</code> &#x2F; <code>killall 进程名</code>：按名杀死</li><li><code>killall -u 用户名</code>：杀死指定用户的所有进程</li></ul></li><li><p><strong>进程优先级</strong></p><ul><li><code>nice -n 10 命令</code>：以较低优先级运行命令</li><li><code>renice +10 -p PID</code>：调整运行中进程的优先级</li></ul></li><li><p><strong>后台与作业控制</strong></p><ul><li><code>command &amp;</code>：后台运行</li><li><code>jobs</code>：查看后台作业，<code>fg %1</code> 将第 1 个作业拉到前台，<code>bg %1</code> 让其后台运行</li><li><code>nohup command &amp;</code>：后台运行且忽略挂断信号（退出终端后继续运行）</li><li><code>Ctrl+Z</code>：挂起当前进程</li><li><code>Ctrl+C</code>：终止当前进程</li></ul></li></ol><hr><h2 id="五、网络与远程操作-1"><a href="#五、网络与远程操作-1" class="headerlink" title="五、网络与远程操作"></a>五、网络与远程操作</h2><ol><li><p><strong>网络诊断</strong></p><ul><li><code>ping 主机</code>：连通性测试</li><li><code>ping -c 4</code>：只发送 4 个数据包</li><li><code>traceroute 主机</code>：路由追踪</li><li><code>mtr 主机</code>：结合 ping 和 traceroute 功能</li><li><code>netstat -anp</code>：查看端口、连接；常与 <code>grep</code> 结合</li><li><code>ss -tulnp</code>：更现代的端口查看工具</li><li><code>nmap 主机</code>：端口扫描（需要安装）</li></ul></li><li><p><strong>DNS 查询</strong></p><ul><li><code>nslookup 域名</code>：查询 DNS 记录</li><li><code>dig 域名</code>：详细 DNS 查询</li><li><code>host 域名</code>：简单 DNS 查询</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">nslookup google.com                  # 查询域名的 IP 地址dig @8.8.8.8 example.com            # 使用指定 DNS 服务器查询dig example.com MX                   # 查询邮件服务器记录host -t AAAA ipv6.google.com        # 查询 IPv6 地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>网络配置</strong></p><ul><li><code>ifconfig</code>：查看网络接口（较旧）</li><li><code>ip addr show</code>：查看 IP 地址（现代替代 ifconfig）</li><li><code>ip route show</code>：查看路由表</li><li><code>hostname</code>：显示主机名</li><li><code>hostname -I</code>：显示所有 IP 地址</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">ip addr show eth0                    # 显示特定网卡信息ip route add 192.168.1.0/24 via 192.168.1.1  # 添加静态路由ip link set eth0 up                  # 启用网卡ifconfig eth0 192.168.1.100         # 设置 IP 地址（旧方式）sudo hostnamectl set-hostname newname  # 修改主机名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>文件传输与远程登录</strong></p><ul><li><code>ssh user@host</code>：远程登录</li><li><code>ssh -p 端口 user@host</code>：指定端口登录</li><li><code>scp 本地 远端</code> &#x2F; <code>scp user@host:远端 本地</code>：安全复制</li><li><code>sftp user@host</code>：安全文件传输</li><li><code>rsync -avz 源 目标</code>：增量同步</li><li><code>rsync -avz --delete 源 目标</code>：同步并删除目标中源没有的文件</li></ul></li><li><p><strong>下载工具</strong></p><ul><li><code>wget URL</code>：下载文件</li><li><code>wget -c URL</code>：断点续传</li><li><code>curl URL</code>：发送网络请求</li><li><code>curl -O URL</code>：下载文件</li><li><code>curl -H &quot;Header: Value&quot; URL</code>：添加请求头</li></ul></li><li><p><strong>查看公网 IP</strong></p><ul><li><code>curl -4 ifconfig.co</code> 或 <code>curl ipinfo.io/ip</code></li><li><code>curl icanhazip.com</code></li></ul></li></ol><hr><h2 id="六、磁盘与存储-1"><a href="#六、磁盘与存储-1" class="headerlink" title="六、磁盘与存储"></a>六、磁盘与存储</h2><ol><li><p><strong>磁盘使用情况</strong></p><ul><li><code>df -h</code>：查看各分区总量与剩余空间</li><li><code>df -i</code>：查看 inode 使用情况</li><li><code>du -sh 目录</code>：查看目录总占用；<code>du -h --max-depth=1</code> 查看子目录分布</li><li><code>du -h | sort -h</code>：按大小排序显示</li><li><code>ncdu</code>：交互式磁盘使用分析（需要安装）</li></ul></li><li><p><strong>块设备管理</strong></p><ul><li><code>lsblk</code>：列出块设备信息</li><li><code>blkid</code>：显示块设备属性</li><li><code>fdisk -l</code>：列出磁盘分区信息</li><li><code>parted -l</code>：列出分区信息（支持 GPT）</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">lsblk -f                             # 显示文件系统类型blkid /dev/sda1                      # 显示分区 UUID 和类型sudo fdisk -l /dev/sda               # 查看磁盘分区表sudo parted /dev/sda print           # 显示分区信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>文件系统操作</strong></p><ul><li><code>mount 设备 挂载点</code>：挂载文件系统</li><li><code>umount 设备/挂载点</code>：卸载文件系统</li><li><code>mount -o remount,rw /</code>：重新挂载为读写模式</li><li><code>fsck 设备</code>：文件系统检查和修复</li><li><code>mkfs.ext4 设备</code>：创建 ext4 文件系统</li></ul></li><li><p><strong>打包压缩</strong></p><ul><li><code>tar -czvf archive.tar.gz 目录/文件</code>：打包并 gzip 压缩</li><li><code>tar -xzvf archive.tar.gz</code>：解压</li><li><code>tar -tf archive.tar</code>：查看压缩包内容而不解压</li><li><code>zip -r archive.zip 目录</code> &#x2F; <code>unzip archive.zip</code></li><li><code>gzip 文件</code> &#x2F; <code>gunzip 文件.gz</code></li><li><code>bzip2 文件</code> &#x2F; <code>bunzip2 文件.bz2</code></li><li><code>xz 文件</code> &#x2F; <code>unxz 文件.xz</code></li></ul></li><li><p><strong>数据复制与备份</strong></p><ul><li><code>dd if=源 of=目标 bs=块大小</code>：数据复制</li><li><code>dd if=/dev/zero of=file bs=1M count=100</code>：创建100M空文件</li><li><code>cp --sparse=always 文件 目标</code>：复制稀疏文件</li></ul></li></ol><hr><h2 id="七、查找与批处理-1"><a href="#七、查找与批处理-1" class="headerlink" title="七、查找与批处理"></a>七、查找与批处理</h2><ol><li><p><strong>查找文件</strong></p><ul><li><code>find . -name &#39;*.log&#39;</code>：当前目录及子目录查找</li><li><code>find /path -type f -mtime -7</code>：查找 7 天内修改的文件</li><li><code>find . -type f -name &#39;xiaohub.log.2024-06*&#39; -delete</code>：批量删除</li><li><code>find . -size +100M</code>：查找大于 100M 的文件</li><li><code>find . -empty</code>：查找空文件或空目录</li><li><code>find . -perm 777</code>：查找权限为 777 的文件</li></ul></li><li><p><strong>快速定位</strong></p><ul><li><code>locate 文件名</code>：快速查找文件（基于数据库）</li><li><code>updatedb</code>：更新 locate 数据库</li><li><code>which 命令</code>：查找命令的完整路径</li><li><code>whereis 命令</code>：查找二进制、源代码和手册页位置</li><li><code>type 命令</code>：显示命令类型（别名、内置、外部命令）</li></ul></li><li><p><strong>批量执行</strong></p><ul><li>与 <code>find</code> + <code>-exec</code>：<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.sh' -exec chmod +x &#123;&#125; \;find /var/log -name '*.log' -exec cp &#123;&#125; &#123;&#125;.bak \;find . -type f -exec md5sum &#123;&#125; \; > checksums.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><code>xargs</code>：<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.txt' | xargs grep '关键字'find . -name '*.tmp' | xargs rm -fls *.jpg | xargs -I &#123;&#125; convert &#123;&#125; &#123;&#125;.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><code>parallel</code>：并行执行命令（需要安装）<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.jpg' | parallel convert &#123;&#125; &#123;.&#125;.pngcat urls.txt | parallel wget &#123;&#125;seq 1 10 | parallel -j4 'echo "Process &#123;&#125;"'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><hr><h2 id="八、Shell-环境与脚本-1"><a href="#八、Shell-环境与脚本-1" class="headerlink" title="八、Shell 环境与脚本"></a>八、Shell 环境与脚本</h2><ol><li><p><strong>环境变量</strong></p><ul><li><code>export VAR=value</code>：临时设置；写入 <code>~/.bashrc</code> 或 <code>~/.profile</code> 实现持久</li><li><code>echo $VAR</code>：显示变量值</li><li><code>env</code>：显示所有环境变量</li><li><code>set</code>：显示所有变量（包括局部变量）</li><li><code>unset VAR</code>：删除变量</li><li><code>source 文件</code> 或 <code>.</code>：重新加载配置</li></ul></li><li><p><strong>Shell 配置</strong></p><ul><li><code>~/.bashrc</code>：bash shell 配置文件</li><li><code>~/.bash_profile</code>：登录 shell 配置文件</li><li><code>~/.bash_history</code>：命令历史记录</li></ul></li><li><p><strong>常见提示</strong></p><ul><li><code>history</code>：查看历史命令；<code>!n</code> 重复第 n 条，<code>!!</code> 重复上一条</li><li><code>history -c</code>：清除历史记录</li><li><code>Ctrl+R</code>：反向搜索历史命令</li><li>Tab 自动补全</li><li><code>alias ll=&#39;ls -l&#39;</code>：自定义快捷命令，写入 <code>~/.bashrc</code> 生效</li><li><code>unalias 别名</code>：删除别名</li></ul></li><li><p><strong>目录操作</strong></p><ul><li><code>pushd 目录</code>：将目录压入堆栈并切换</li><li><code>popd</code>：从堆栈弹出目录并切换</li><li><code>dirs</code>：显示目录堆栈</li></ul></li><li><p><strong>脚本规范</strong></p><ul><li>首行 <code>#!/bin/bash</code> 或 <code>#!/usr/bin/env bash</code></li><li>脚本执行前加执行权限：<code>chmod +x script.sh</code></li><li>参数获取：<code>$1,$2,…</code>；循环 <code>for arg in &quot;$@&quot;; do …; done</code></li><li><code>$0</code>：脚本名称</li><li><code>$#</code>：参数个数</li><li><code>$?</code>：上个命令的退出状态</li><li><code>test</code> 或 <code>[ ]</code>：条件测试</li><li><code>[[ ]]</code>：扩展的条件测试（支持正则）</li></ul></li></ol><hr><h2 id="九、系统管理-1"><a href="#九、系统管理-1" class="headerlink" title="九、系统管理"></a>九、系统管理</h2><ol><li><p><strong>服务与日志</strong></p><ul><li><code>systemctl status 服务名</code>：查看服务状态</li><li><code>systemctl start/stop/restart 服务名</code>：启停服务</li><li><code>systemctl enable/disable 服务名</code>：开机自启设置</li><li><code>journalctl -u 服务名</code>：查看 systemd 日志</li><li><code>journalctl -f</code>：实时查看系统日志</li></ul></li><li><p><strong>定时任务</strong></p><ul><li><code>crontab -e</code>：编辑当前用户 crontab</li><li><code>crontab -l</code>：列出当前用户的定时任务</li><li>格式：<code>* * * * * command</code>（分 时 日 月 周）</li><li><code>/etc/crontab</code>：系统级定时任务</li></ul></li><li><p><strong>用户与组管理</strong></p><ul><li><code>useradd 用户名</code> &#x2F; <code>usermod -aG group 用户名</code> &#x2F; <code>userdel 用户名</code></li><li><code>passwd 用户名</code>：设置用户密码</li><li><code>groups 用户名</code>：查看用户所属组</li><li><code>id 用户名</code>：显示用户和组 ID</li><li><code>su - 用户名</code>：切换用户</li><li><code>sudo 命令</code>：以 root 权限执行命令</li></ul></li><li><p><strong>系统监控</strong></p><ul><li><code>free -h</code>：查看内存使用情况</li><li><code>uptime</code>：系统运行时间和负载</li><li><code>dmesg</code>：查看内核消息</li><li><code>lsof</code>：列出打开的文件</li><li><code>lsof -i :端口</code>：查看端口占用情况</li><li><code>vmstat</code>：虚拟内存统计</li><li><code>iostat</code>：IO 统计</li><li><code>sar</code>：系统活动报告（需要安装 sysstat）</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">free -h                              # 显示人性化的内存使用信息uptime                               # 显示运行时间和负载dmesg | tail -20                     # 查看最近的内核消息lsof -i :80                          # 查看 80 端口占用lsof -p 1234                         # 查看进程 1234 打开的文件vmstat 2 5                           # 每 2 秒更新一次，共 5 次iostat -x 1                          # 每秒显示详细 IO 统计sar -u 1 5                           # CPU 使用率，每秒更新，共 5 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="十、软件包管理-1"><a href="#十、软件包管理-1" class="headerlink" title="十、软件包管理"></a>十、软件包管理</h2><ol><li><p><strong>Debian&#x2F;Ubuntu（APT）</strong></p><ul><li><code>apt update</code>：更新软件包列表</li><li><code>apt upgrade</code>：升级已安装软件包</li><li><code>apt install 软件包</code>：安装软件</li><li><code>apt remove 软件包</code>：删除软件</li><li><code>apt search 关键字</code>：搜索软件包</li><li><code>apt show 软件包</code>：显示软件包信息</li><li><code>apt autoremove</code>：删除不需要的依赖包</li></ul></li><li><p><strong>RHEL&#x2F;CentOS（YUM&#x2F;DNF）</strong></p><ul><li><code>yum update</code>：更新软件包</li><li><code>yum install 软件包</code>：安装软件</li><li><code>yum remove 软件包</code>：删除软件</li><li><code>yum search 关键字</code>：搜索软件包</li><li><code>yum info 软件包</code>：显示软件包信息</li><li><code>dnf</code>：新版本的 Fedora&#x2F;RHEL 使用 dnf 替代 yum</li></ul></li><li><p><strong>常用工具安装</strong></p><ul><li><code>apt install net-tools</code>：安装传统网络工具（ifconfig 等）</li><li><code>apt install vim</code>：安装 vim 编辑器</li><li><code>apt install htop</code>：安装 htop 进程监控工具</li><li><code>apt install ncdu</code>：安装磁盘使用分析工具</li></ul></li></ol><hr><h2 id="十一、快捷键与技巧-1"><a href="#十一、快捷键与技巧-1" class="headerlink" title="十一、快捷键与技巧"></a>十一、快捷键与技巧</h2><ol><li><strong>终端快捷键</strong><ul><li><code>Ctrl+A</code>：移到行首</li><li><code>Ctrl+E</code>：移到行尾</li><li><code>Ctrl+U</code>：删除光标前的内容</li><li><code>Ctrl+K</code>：删除光标后的内容</li><li><code>Ctrl+W</code>：删除光标前的单词</li><li><code>Ctrl+L</code>：清屏（等同于 clear）</li><li><code>Ctrl+D</code>：退出当前 shell</li></ul></li></ol><p>：引用上条命令的最后一个参数</p><ul><li><code>!*</code>：引用上条命令的所有参数</li><li><code>command1 &amp;&amp; command2</code>：前一个命令成功后才执行后一个</li><li><code>command1 || command2</code>：前一个命令失败后才执行后一个</li><li><code>command1; command2</code>：顺序执行，不管是否成功</li><li><code>$(command)</code>：命令替换</li><li><code>`command`</code>：命令替换（旧式）</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">sudo !!                              # 以 root 权限重新执行上条命令cd !$                                # 切换到上条命令的最后一个参数echo !*                              # 显示上条命令的所有参数mkdir test && cd test                # 创建目录并进入ping -c1 google.com || echo "网络不通"  # 网络不通时提示echo "今天是 $(date +%Y-%m-%d)"      # 命令替换显示日期for file in *.txt; do echo $file; done  # 遍历文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p><strong>通配符与正则</strong></p><ul><li><code>*</code>：匹配任意多个字符</li><li><code>?</code>：匹配单个字符</li><li><code>[abc]</code>：匹配中括号内任一字符</li><li><code>[a-z]</code>：匹配范围内任一字符</li><li><code>&#123;a,b,c&#125;</code>：匹配大括号内任一字符串</li></ul></li><li><p><strong>重定向与管道</strong></p><ul><li><code>&gt;</code>：输出重定向（覆盖）</li><li><code>&gt;&gt;</code>：输出重定向（追加）</li><li><code>2&gt;</code>：错误输出重定向</li><li><code>&amp;&gt;</code>：标准输出和错误都重定向</li><li><code>|</code>：管道，将前一个命令的输出作为后一个命令的输入</li><li><code>tee</code>：将输出同时写入文件和标准输出 phone.txt      # 正则匹配电话号码格式<br>ps aux | grep nginx | grep -v grep            # 查找 nginx 进程（排除 grep 自身）<br>awk -F: ‘{print $1,$7}’ &#x2F;etc&#x2F;passwd           # 显示用户名和 shell<br>df -h | awk ‘NR&gt;1{print $5,$6}’              # 显示磁盘使用率和挂载点<br>sed -i ‘s&#x2F;localhost&#x2F;127.0.0.1&#x2F;g’ config.ini   # 直接替换文件内容<br>sed -n ‘&#x2F;start&#x2F;,&#x2F;end&#x2F;p’ log.txt               # 显示两个标记之间的行</li></ul><pre><code></code></pre></li><li><p><strong>排序与去重</strong></p><ul><li><code>sort 文件</code>：排序；<code>sort -n</code> 数值排序；<code>-r</code> 逆序；<code>-k n</code> 指定第 n 列排序</li><li><code>uniq 文件</code>：去除相邻重复；<code>uniq -c</code> 统计次数；常与 <code>sort</code> 管道配合：<pre class="line-numbers language-language-bash"><code class="language-language-bash">sort abc.txt | uniq -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>comm 文件1 文件2</code>：比较两个已排序文件的异同</li></ul></li><li><p><strong>统计与比较</strong></p><ul><li><code>wc -l 文件</code>：统计行数；<code>-m</code> 字符数；<code>-c</code> 字节数；<code>-L</code> 最长行长度；<code>-w</code> 单词数</li><li><code>diff 文件1 文件2</code>：比较文件差异</li><li><code>diff -u</code>：以统一格式显示差异</li><li><code>cmp 文件1 文件2</code>：二进制比较文件</li></ul></li><li><p><strong>字符转换</strong></p><ul><li><code>tr &#39;a-z&#39; &#39;A-Z&#39; &lt; 文件</code>：小写转大写</li><li><code>tr -d &#39;0-9&#39;</code>：删除所有数字</li><li><code>tr -s &#39; &#39;</code>：压缩连续空格为单个空格</li></ul></li></ol><hr><h2 id="三、权限与拥有者-2"><a href="#三、权限与拥有者-2" class="headerlink" title="三、权限与拥有者"></a>三、权限与拥有者</h2><ol><li><p><strong>查看权限</strong></p><ul><li><code>ls -l</code> 第一列如 <code>-rwxr-xr--</code>：分别是文件类型、用户&#x2F;组&#x2F;其他用户的读(r)&#x2F;写(w)&#x2F;执行(x) 权限</li><li><code>stat 文件</code>：查看文件详细状态信息</li></ul></li><li><p><strong>修改权限</strong></p><ul><li><code>chmod u+rw 文件</code>：用户添加读写权限；也可用数字模式，如 <code>chmod 755 文件</code></li><li><code>chmod g-w 文件</code>：组移除写权限</li><li><code>chmod o+x 文件</code>：其他用户添加执行权限</li><li><code>chmod -R 755 目录</code>：递归修改目录及子目录权限</li></ul></li><li><p><strong>修改拥有者&#x2F;所属组</strong></p><ul><li><code>chown user:group 文件</code>：同时修改用户与组</li><li><code>chown user 文件</code> 或 <code>chown :group 文件</code></li><li><code>chown -R user:group 目录</code>：递归修改目录权限</li></ul></li><li><p><strong>特殊权限</strong></p><ul><li><code>chmod u+s 文件</code>：设置 SUID 权限</li><li><code>chmod g+s 目录</code>：设置 SGID 权限</li><li><code>chmod +t 目录</code>：设置粘滞位</li><li><code>umask</code>：查看默认权限掩码</li><li><code>umask 022</code>：设置默认权限掩码</li></ul></li><li><p><strong>文件属性</strong></p><ul><li><code>lsattr 文件</code>：查看文件特殊属性</li><li><code>chattr +i 文件</code>：设置不可修改属性</li><li><code>chattr +a 文件</code>：设置只能追加属性</li></ul></li></ol><hr><h2 id="四、进程与作业管理-2"><a href="#四、进程与作业管理-2" class="headerlink" title="四、进程与作业管理"></a>四、进程与作业管理</h2><ol><li><p><strong>查看进程</strong></p><ul><li><code>ps -ef</code>：列出所有进程；常与 <code>grep</code> 结合过滤</li><li><code>ps aux</code>：显示详细进程信息</li><li><code>pstree</code>：以树状图显示进程关系</li><li><code>top</code> &#x2F; <code>htop</code>：动态监控 CPU&#x2F;内存&#x2F;进程（按 q 退出）</li><li><code>pgrep 进程名</code>：按名称查找进程 ID</li></ul></li><li><p><strong>杀死进程</strong></p><ul><li><code>kill PID</code>：温和终止（发送 SIGTERM 信号）</li><li><code>kill -9 PID</code>：强制终止（发送 SIGKILL 信号）</li><li><code>kill -l</code>：列出所有信号</li><li><code>pkill 进程名</code> &#x2F; <code>killall 进程名</code>：按名杀死</li><li><code>killall -u 用户名</code>：杀死指定用户的所有进程</li></ul></li><li><p><strong>进程优先级</strong></p><ul><li><code>nice -n 10 命令</code>：以较低优先级运行命令</li><li><code>renice +10 -p PID</code>：调整运行中进程的优先级</li></ul></li><li><p><strong>后台与作业控制</strong></p><ul><li><code>command &amp;</code>：后台运行</li><li><code>jobs</code>：查看后台作业，<code>fg %1</code> 将第 1 个作业拉到前台，<code>bg %1</code> 让其后台运行</li><li><code>nohup command &amp;</code>：后台运行且忽略挂断信号（退出终端后继续运行）</li><li><code>Ctrl+Z</code>：挂起当前进程</li><li><code>Ctrl+C</code>：终止当前进程</li></ul></li></ol><hr><h2 id="五、网络与远程操作-2"><a href="#五、网络与远程操作-2" class="headerlink" title="五、网络与远程操作"></a>五、网络与远程操作</h2><ol><li><p><strong>网络诊断</strong></p><ul><li><code>ping 主机</code>：连通性测试</li><li><code>ping -c 4</code>：只发送 4 个数据包</li><li><code>traceroute 主机</code>：路由追踪</li><li><code>mtr 主机</code>：结合 ping 和 traceroute 功能</li><li><code>netstat -anp</code>：查看端口、连接；常与 <code>grep</code> 结合</li><li><code>ss -tulnp</code>：更现代的端口查看工具</li><li><code>nmap 主机</code>：端口扫描（需要安装）</li></ul></li><li><p><strong>DNS 查询</strong></p><ul><li><code>nslookup 域名</code>：查询 DNS 记录</li><li><code>dig 域名</code>：详细 DNS 查询</li><li><code>host 域名</code>：简单 DNS 查询</li></ul></li><li><p><strong>网络配置</strong></p><ul><li><code>ifconfig</code>：查看网络接口（较旧）</li><li><code>ip addr show</code>：查看 IP 地址（现代替代 ifconfig）</li><li><code>ip route show</code>：查看路由表</li><li><code>hostname</code>：显示主机名</li><li><code>hostname -I</code>：显示所有 IP 地址</li></ul></li><li><p><strong>文件传输与远程登录</strong></p><ul><li><code>ssh user@host</code>：远程登录</li><li><code>ssh -p 端口 user@host</code>：指定端口登录</li><li><code>scp 本地 远端</code> &#x2F; <code>scp user@host:远端 本地</code>：安全复制</li><li><code>sftp user@host</code>：安全文件传输</li><li><code>rsync -avz 源 目标</code>：增量同步</li><li><code>rsync -avz --delete 源 目标</code>：同步并删除目标中源没有的文件</li></ul></li><li><p><strong>下载工具</strong></p><ul><li><code>wget URL</code>：下载文件</li><li><code>wget -c URL</code>：断点续传</li><li><code>curl URL</code>：发送网络请求</li><li><code>curl -O URL</code>：下载文件</li><li><code>curl -H &quot;Header: Value&quot; URL</code>：添加请求头</li></ul></li><li><p><strong>查看公网 IP</strong></p><ul><li><code>curl -4 ifconfig.co</code> 或 <code>curl ipinfo.io/ip</code></li><li><code>curl icanhazip.com</code></li></ul></li></ol><hr><h2 id="六、磁盘与存储-2"><a href="#六、磁盘与存储-2" class="headerlink" title="六、磁盘与存储"></a>六、磁盘与存储</h2><ol><li><p><strong>磁盘使用情况</strong></p><ul><li><code>df -h</code>：查看各分区总量与剩余空间</li><li><code>df -i</code>：查看 inode 使用情况</li><li><code>du -sh 目录</code>：查看目录总占用；<code>du -h --max-depth=1</code> 查看子目录分布</li><li><code>du -h | sort -h</code>：按大小排序显示</li><li><code>ncdu</code>：交互式磁盘使用分析（需要安装）</li></ul></li><li><p><strong>块设备管理</strong></p><ul><li><code>lsblk</code>：列出块设备信息</li><li><code>blkid</code>：显示块设备属性</li><li><code>fdisk -l</code>：列出磁盘分区信息</li><li><code>parted -l</code>：列出分区信息（支持 GPT）</li></ul></li><li><p><strong>文件系统操作</strong></p><ul><li><code>mount 设备 挂载点</code>：挂载文件系统</li><li><code>umount 设备/挂载点</code>：卸载文件系统</li><li><code>mount -o remount,rw /</code>：重新挂载为读写模式</li><li><code>fsck 设备</code>：文件系统检查和修复</li><li><code>mkfs.ext4 设备</code>：创建 ext4 文件系统</li></ul></li><li><p><strong>打包压缩</strong></p><ul><li><code>tar -czvf archive.tar.gz 目录/文件</code>：打包并 gzip 压缩</li><li><code>tar -xzvf archive.tar.gz</code>：解压</li><li><code>tar -tf archive.tar</code>：查看压缩包内容而不解压</li><li><code>zip -r archive.zip 目录</code> &#x2F; <code>unzip archive.zip</code></li><li><code>gzip 文件</code> &#x2F; <code>gunzip 文件.gz</code></li><li><code>bzip2 文件</code> &#x2F; <code>bunzip2 文件.bz2</code></li><li><code>xz 文件</code> &#x2F; <code>unxz 文件.xz</code></li></ul></li><li><p><strong>数据复制与备份</strong></p><ul><li><code>dd if=源 of=目标 bs=块大小</code>：数据复制</li><li><code>dd if=/dev/zero of=file bs=1M count=100</code>：创建100M空文件</li><li><code>cp --sparse=always 文件 目标</code>：复制稀疏文件</li></ul></li></ol><hr><h2 id="七、查找与批处理-2"><a href="#七、查找与批处理-2" class="headerlink" title="七、查找与批处理"></a>七、查找与批处理</h2><ol><li><p><strong>查找文件</strong></p><ul><li><code>find . -name &#39;*.log&#39;</code>：当前目录及子目录查找</li><li><code>find /path -type f -mtime -7</code>：查找 7 天内修改的文件</li><li><code>find . -type f -name &#39;xiaohub.log.2024-06*&#39; -delete</code>：批量删除</li><li><code>find . -size +100M</code>：查找大于 100M 的文件</li><li><code>find . -empty</code>：查找空文件或空目录</li><li><code>find . -perm 777</code>：查找权限为 777 的文件</li></ul></li><li><p><strong>快速定位</strong></p><ul><li><code>locate 文件名</code>：快速查找文件（基于数据库）</li><li><code>updatedb</code>：更新 locate 数据库</li><li><code>which 命令</code>：查找命令的完整路径</li><li><code>whereis 命令</code>：查找二进制、源代码和手册页位置</li><li><code>type 命令</code>：显示命令类型（别名、内置、外部命令）</li></ul></li><li><p><strong>批量执行</strong></p><ul><li>与 <code>find</code> + <code>-exec</code>：<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.sh' -exec chmod +x &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>xargs</code>：<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.txt' | xargs grep '关键字'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>parallel</code>：并行执行命令（需要安装）<pre class="line-numbers language-language-bash"><code class="language-language-bash">find . -name '*.jpg' | parallel convert &#123;&#125; &#123;.&#125;.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ol><hr><h2 id="八、Shell-环境与脚本-2"><a href="#八、Shell-环境与脚本-2" class="headerlink" title="八、Shell 环境与脚本"></a>八、Shell 环境与脚本</h2><ol><li><p><strong>环境变量</strong></p><ul><li><code>export VAR=value</code>：临时设置；写入 <code>~/.bashrc</code> 或 <code>~/.profile</code> 实现持久</li><li><code>echo $VAR</code>：显示变量值</li><li><code>env</code>：显示所有环境变量</li><li><code>set</code>：显示所有变量（包括局部变量）</li><li><code>unset VAR</code>：删除变量</li><li><code>source 文件</code> 或 <code>.</code>：重新加载配置</li></ul></li><li><p><strong>Shell 配置</strong></p><ul><li><code>~/.bashrc</code>：bash shell 配置文件</li><li><code>~/.bash_profile</code>：登录 shell 配置文件</li><li><code>~/.bash_history</code>：命令历史记录</li></ul></li><li><p><strong>常见提示</strong></p><ul><li><code>history</code>：查看历史命令；<code>!n</code> 重复第 n 条，<code>!!</code> 重复上一条</li><li><code>history -c</code>：清除历史记录</li><li><code>Ctrl+R</code>：反向搜索历史命令</li><li>Tab 自动补全</li><li><code>alias ll=&#39;ls -l&#39;</code>：自定义快捷命令，写入 <code>~/.bashrc</code> 生效</li><li><code>unalias 别名</code>：删除别名</li></ul></li><li><p><strong>目录操作</strong></p><ul><li><code>pushd 目录</code>：将目录压入堆栈并切换</li><li><code>popd</code>：从堆栈弹出目录并切换</li><li><code>dirs</code>：显示目录堆栈</li></ul></li><li><p><strong>脚本规范</strong></p><ul><li>首行 <code>#!/bin/bash</code> 或 <code>#!/usr/bin/env bash</code></li><li>脚本执行前加执行权限：<code>chmod +x script.sh</code></li><li>参数获取：<code>$1,$2,…</code>；循环 <code>for arg in &quot;$@&quot;; do …; done</code></li><li><code>$0</code>：脚本名称</li><li><code>$#</code>：参数个数</li><li><code>$?</code>：上个命令的退出状态</li><li><code>test</code> 或 <code>[ ]</code>：条件测试</li><li><code>[[ ]]</code>：扩展的条件测试（支持正则）</li></ul></li></ol><hr><h2 id="九、系统管理-2"><a href="#九、系统管理-2" class="headerlink" title="九、系统管理"></a>九、系统管理</h2><ol><li><p><strong>服务与日志</strong></p><ul><li><code>systemctl status 服务名</code>：查看服务状态</li><li><code>systemctl start/stop/restart 服务名</code>：启停服务</li><li><code>systemctl enable/disable 服务名</code>：开机自启设置</li><li><code>journalctl -u 服务名</code>：查看 systemd 日志</li><li><code>journalctl -f</code>：实时查看系统日志</li></ul></li><li><p><strong>定时任务</strong></p><ul><li><code>crontab -e</code>：编辑当前用户 crontab</li><li><code>crontab -l</code>：列出当前用户的定时任务</li><li>格式：<code>* * * * * command</code>（分 时 日 月 周）</li><li><code>/etc/crontab</code>：系统级定时任务</li></ul></li><li><p><strong>用户与组管理</strong></p><ul><li><code>useradd 用户名</code> &#x2F; <code>usermod -aG group 用户名</code> &#x2F; <code>userdel 用户名</code></li><li><code>passwd 用户名</code>：设置用户密码</li><li><code>groups 用户名</code>：查看用户所属组</li><li><code>id 用户名</code>：显示用户和组 ID</li><li><code>su - 用户名</code>：切换用户</li><li><code>sudo 命令</code>：以 root 权限执行命令</li></ul></li><li><p><strong>系统监控</strong></p><ul><li><code>free -h</code>：查看内存使用情况</li><li><code>uptime</code>：系统运行时间和负载</li><li><code>dmesg</code>：查看内核消息</li><li><code>lsof</code>：列出打开的文件</li><li><code>lsof -i :端口</code>：查看端口占用情况</li><li><code>vmstat</code>：虚拟内存统计</li><li><code>iostat</code>：IO 统计</li><li><code>sar</code>：系统活动报告（需要安装 sysstat）</li></ul></li></ol><hr><h2 id="十、软件包管理-2"><a href="#十、软件包管理-2" class="headerlink" title="十、软件包管理"></a>十、软件包管理</h2><ol><li><p><strong>Debian&#x2F;Ubuntu（APT）</strong></p><ul><li><code>apt update</code>：更新软件包列表</li><li><code>apt upgrade</code>：升级已安装软件包</li><li><code>apt install 软件包</code>：安装软件</li><li><code>apt remove 软件包</code>：删除软件</li><li><code>apt search 关键字</code>：搜索软件包</li><li><code>apt show 软件包</code>：显示软件包信息</li><li><code>apt autoremove</code>：删除不需要的依赖包</li></ul></li><li><p><strong>RHEL&#x2F;CentOS（YUM&#x2F;DNF）</strong></p><ul><li><code>yum update</code>：更新软件包</li><li><code>yum install 软件包</code>：安装软件</li><li><code>yum remove 软件包</code>：删除软件</li><li><code>yum search 关键字</code>：搜索软件包</li><li><code>yum info 软件包</code>：显示软件包信息</li><li><code>dnf</code>：新版本的 Fedora&#x2F;RHEL 使用 dnf 替代 yum</li></ul></li><li><p><strong>常用工具安装</strong></p><ul><li><code>apt install net-tools</code>：安装传统网络工具（ifconfig 等）</li><li><code>apt install vim</code>：安装 vim 编辑器</li><li><code>apt install htop</code>：安装 htop 进程监控工具</li><li><code>apt install ncdu</code>：安装磁盘使用分析工具</li></ul></li></ol><hr><h2 id="十一、快捷键与技巧-2"><a href="#十一、快捷键与技巧-2" class="headerlink" title="十一、快捷键与技巧"></a>十一、快捷键与技巧</h2><ol><li><p><strong>终端快捷键</strong></p><ul><li><code>Ctrl+A</code>：移到行首</li><li><code>Ctrl+E</code>：移到行尾</li><li><code>Ctrl+U</code>：删除光标前的内容</li><li><code>Ctrl+K</code>：删除光标后的内容</li><li><code>Ctrl+W</code>：删除光标前的单词</li><li><code>Ctrl+L</code>：清屏（等同于 clear）</li><li><code>Ctrl+D</code>：退出当前 shell</li></ul></li><li><p><strong>命令行技巧</strong></p><ul><li><code>!!</code>：重复执行上一条命令</li><li><code>!$</code>：引用上条命令的最后一个参数</li><li><code>!*</code>：引用上条命令的所有参数</li><li><code>command1 &amp;&amp; command2</code>：前一个命令成功后才执行后一个</li><li><code>command1 || command2</code>：前一个命令失败后才执行后一个</li><li><code>command1; command2</code>：顺序执行，不管是否成功</li><li><code>$(command)</code>：命令替换</li><li><code>`command`</code>：命令替换（旧式）</li></ul></li><li><p><strong>通配符与正则</strong></p><ul><li><code>*</code>：匹配任意多个字符</li><li><code>?</code>：匹配单个字符</li><li><code>[abc]</code>：匹配中括号内任一字符</li><li><code>[a-z]</code>：匹配范围内任一字符</li><li><code>&#123;a,b,c&#125;</code>：匹配大括号内任一字符串</li></ul></li><li><p><strong>重定向与管道</strong></p><ul><li><code>&gt;</code>：输出重定向（覆盖）</li><li><code>&gt;&gt;</code>：输出重定向（追加）</li><li><code>2&gt;</code>：错误输出重定向</li><li><code>&amp;&gt;</code>：标准输出和错误都重定向</li><li><code>|</code>：管道，将前一个命令的输出作为后一个命令的输入</li><li><code>tee</code>：将输出同时写入文件和标准输出</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 命令完整笔记</title>
      <link href="/2024/07/15/docker-bi-ji/"/>
      <url>/2024/07/15/docker-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Docker-基础配置"><a href="#一、Docker-基础配置" class="headerlink" title="一、Docker 基础配置"></a>一、Docker 基础配置</h2><ol><li><p><strong>安装后配置</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 将当前用户添加到docker组（避免每次使用sudo）sudo usermod -aG docker $USER# 配置Docker开机自启sudo systemctl enable dockersudo systemctl start docker# 查看Docker版本docker versiondocker info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>配置镜像加速器</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 编辑Docker配置文件sudo vim /etc/docker/daemon.json# 添加镜像加速器配置&#123;  "registry-mirrors": [    "https://docker.m.daocloud.io",    "https://dockerproxy.com",    "https://docker.mirrors.ustc.edu.cn",    "https://docker.nju.edu.cn",    "https://iju9kaj2.mirror.aliyuncs.com",    "http://hub-mirror.c.163.com",    "https://cr.console.aliyun.com",    "https://hub.docker.com",    "http://mirrors.ustc.edu.cn"  ]&#125;# 重启Docker服务sudo systemctl daemon-reloadsudo systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="二、镜像管理"><a href="#二、镜像管理" class="headerlink" title="二、镜像管理"></a>二、镜像管理</h2><ol><li><p><strong>搜索和拉取镜像</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker search nginx                 # 搜索镜像docker pull nginx                   # 拉取最新版本docker pull nginx:1.21              # 拉取指定版本docker pull ubuntu:20.04            # 拉取Ubuntu 20.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看本地镜像</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker images                       # 列出本地镜像docker images -a                    # 显示所有镜像（包括中间层）docker images nginx                 # 查看特定镜像docker images --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"  # 自定义格式输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>镜像详细信息</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker inspect nginx                # 查看镜像详细信息docker history nginx                # 查看镜像历史docker image prune                  # 清理未使用的镜像docker rmi nginx:1.21               # 删除指定镜像docker rmi $(docker images -q)      # 删除所有镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>保存和加载镜像</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker save -o nginx.tar nginx:latest     # 保存镜像到tar文件docker load -i nginx.tar                  # 从tar文件加载镜像docker save nginx:latest | gzip > nginx.tar.gz  # 压缩保存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>构建镜像</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker build -t myapp:1.0 .              # 从Dockerfile构建docker build -t myapp:1.0 -f Dockerfile.dev .  # 指定Dockerfiledocker build --no-cache -t myapp:1.0 .   # 不使用缓存构建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="三、容器管理"><a href="#三、容器管理" class="headerlink" title="三、容器管理"></a>三、容器管理</h2><ol><li><p><strong>运行容器</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run nginx                    # 运行nginx容器docker run -d nginx                 # 后台运行docker run -p 8080:80 nginx         # 端口映射docker run --name mynginx nginx     # 指定容器名称docker run -it ubuntu bash          # 交互式运行docker run -e MYSQL_ROOT_PASSWORD=123456 mysql  # 设置环境变量docker run -v /host/data:/container/data nginx  # 挂载数据卷docker run --rm nginx               # 容器退出后自动删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看容器</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker ps                           # 查看运行中的容器docker ps -a                        # 查看所有容器docker ps -q                        # 只显示容器IDdocker ps --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>容器操作</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker start container_id           # 启动容器docker stop container_id            # 停止容器docker restart container_id         # 重启容器docker pause container_id           # 暂停容器docker unpause container_id         # 恢复容器docker rm container_id              # 删除容器docker rm -f container_id           # 强制删除运行中的容器docker container prune              # 清理停止的容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>容器交互</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker exec -it container_id bash   # 进入运行中的容器docker exec container_id ls /app    # 在容器中执行命令docker attach container_id          # 附加到容器docker cp file.txt container_id:/app/  # 复制文件到容器docker cp container_id:/app/file.txt ./  # 从容器复制文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看容器信息</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker logs container_id            # 查看容器日志docker logs -f container_id         # 实时查看日志docker logs --tail 100 container_id # 查看最后100行docker top container_id             # 查看容器进程docker stats                        # 查看容器资源使用docker inspect container_id         # 查看容器详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="四、网络管理"><a href="#四、网络管理" class="headerlink" title="四、网络管理"></a>四、网络管理</h2><ol><li><p><strong>网络操作</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker network ls                   # 列出网络docker network create mynet         # 创建网络docker network inspect bridge       # 查看网络详情docker network rm mynet             # 删除网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>容器网络</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run --network=mynet nginx    # 指定网络运行容器docker network connect mynet container_id    # 连接容器到网络docker network disconnect mynet container_id  # 断开连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>端口映射</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -p 8080:80 nginx         # 映射端口8080到容器80docker run -p 127.0.0.1:8080:80 nginx  # 只绑定本地地址docker run -P nginx                 # 随机映射端口docker port container_id            # 查看端口映射<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="五、数据卷管理"><a href="#五、数据卷管理" class="headerlink" title="五、数据卷管理"></a>五、数据卷管理</h2><ol><li><p><strong>创建和管理数据卷</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker volume create mydata         # 创建数据卷docker volume ls                    # 列出数据卷docker volume inspect mydata        # 查看数据卷详情docker volume rm mydata             # 删除数据卷docker volume prune                 # 清理未使用的数据卷<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用数据卷</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -v mydata:/app nginx     # 挂载命名数据卷docker run -v /host/path:/container/path nginx  # 挂载主机目录docker run --mount source=mydata,target=/app nginx  # 使用--mountdocker run -v $(pwd):/app nginx     # 挂载当前目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="六、Docker-Compose"><a href="#六、Docker-Compose" class="headerlink" title="六、Docker Compose"></a>六、Docker Compose</h2><ol><li><p><strong>基本命令</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker-compose up                   # 启动服务docker-compose up -d                # 后台启动docker-compose down                 # 停止并删除容器docker-compose ps                   # 查看服务状态docker-compose logs                 # 查看日志docker-compose logs -f service_name # 查看特定服务日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>服务管理</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker-compose start                # 启动服务docker-compose stop                 # 停止服务docker-compose restart              # 重启服务docker-compose build                # 构建服务docker-compose pull                 # 拉取服务镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>docker-compose.yml示例</strong></p><pre class="line-numbers language-language-yaml"><code class="language-language-yaml">version: '3'services:  web:    image: nginx:latest    ports:      - "80:80"    volumes:      - ./html:/usr/share/nginx/html    networks:      - webnet    db:    image: mysql:5.7    environment:      MYSQL_ROOT_PASSWORD: password    volumes:      - db_data:/var/lib/mysql    networks:      - webnetvolumes:  db_data:networks:  webnet:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="七、Dockerfile编写"><a href="#七、Dockerfile编写" class="headerlink" title="七、Dockerfile编写"></a>七、Dockerfile编写</h2><ol><li><p><strong>基础指令</strong></p><pre class="line-numbers language-language-dockerfile"><code class="language-language-dockerfile"># 基础镜像FROM node:14-alpine# 维护者信息LABEL maintainer="name@example.com"# 设置工作目录WORKDIR /app# 复制文件COPY package*.json ./COPY . .# 运行命令RUN npm install# 环境变量ENV NODE_ENV=productionENV PORT=3000# 暴露端口EXPOSE 3000# 启动命令CMD ["npm", "start"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>多阶段构建</strong></p><pre class="line-numbers language-language-dockerfile"><code class="language-language-dockerfile"># 构建阶段FROM node:14 AS builderWORKDIR /appCOPY package*.json ./RUN npm installCOPY . .RUN npm run build# 生产阶段FROM nginx:alpineCOPY --from=builder /app/dist /usr/share/nginx/htmlEXPOSE 80CMD ["nginx", "-g", "daemon off;"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>最佳实践</strong></p><pre class="line-numbers language-language-dockerfile"><code class="language-language-dockerfile"># 使用特定版本的基础镜像FROM node:14.17.0-alpine# 使用非root用户RUN addgroup -S appgroup && adduser -S appuser -G appgroupUSER appuser# 利用构建缓存COPY package*.json ./RUN npm installCOPY . .# 减少层数RUN apt-get update && apt-get install -y \    package1 \    package2 \    && rm -rf /var/lib/apt/lists/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="八、镜像仓库操作"><a href="#八、镜像仓库操作" class="headerlink" title="八、镜像仓库操作"></a>八、镜像仓库操作</h2><ol><li><p><strong>登录和推送</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker login                        # 登录Docker Hubdocker login registry.example.com   # 登录私有仓库docker tag myapp:1.0 username/myapp:1.0  # 标记镜像docker push username/myapp:1.0      # 推送镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>私有仓库</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 运行私有仓库docker run -d -p 5000:5000 --name registry registry:2# 标记并推送到私有仓库docker tag myapp:1.0 localhost:5000/myapp:1.0docker push localhost:5000/myapp:1.0# 从私有仓库拉取docker pull localhost:5000/myapp:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="九、容器资源限制"><a href="#九、容器资源限制" class="headerlink" title="九、容器资源限制"></a>九、容器资源限制</h2><ol><li><p><strong>CPU限制</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run --cpus=2 nginx           # 限制使用2个CPUdocker run --cpu-shares=512 nginx   # CPU共享权重docker run --cpuset-cpus="0,1" nginx  # 指定CPU核心<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>内存限制</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -m 512m nginx            # 限制内存512MBdocker run --memory-swap=1g nginx   # 限制总内存(含swap)docker run --oom-kill-disable nginx # 禁用OOM killer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>其他资源限制</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run --device-read-bps /dev/sda:1mb nginx  # 限制磁盘读取速度docker run --device-write-bps /dev/sda:1mb nginx # 限制磁盘写入速度docker run --pids-limit 100 nginx   # 限制进程数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十、Docker健康检查"><a href="#十、Docker健康检查" class="headerlink" title="十、Docker健康检查"></a>十、Docker健康检查</h2><ol><li><p><strong>Dockerfile中定义</strong></p><pre class="line-numbers language-language-dockerfile"><code class="language-language-dockerfile">HEALTHCHECK --interval=30s --timeout=3s \  CMD curl -f http://localhost/ || exit 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>运行时指定</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -d --health-cmd="curl -f http://localhost/ || exit 1" \           --health-interval=30s \           --health-timeout=3s \           --health-retries=3 \           nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看健康状态</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker inspect --format='&#123;&#123;.State.Health.Status&#125;&#125;' container_iddocker ps --filter health=healthy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="十一、日志管理"><a href="#十一、日志管理" class="headerlink" title="十一、日志管理"></a>十一、日志管理</h2><ol><li><p><strong>日志驱动配置</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 配置JSON文件日志驱动docker run --log-driver=json-file \           --log-opt max-size=10m \           --log-opt max-file=3 \           nginx# 配置syslog日志驱动docker run --log-driver=syslog \           --log-opt syslog-address=tcp://192.168.0.42:123 \           nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看日志</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker logs container_id            # 查看容器日志docker logs -f --tail 100 container_id  # 实时查看最后100行docker logs --since 30m container_id    # 查看最近30分钟的日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十二、清理和维护"><a href="#十二、清理和维护" class="headerlink" title="十二、清理和维护"></a>十二、清理和维护</h2><ol><li><p><strong>系统清理</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker system df                    # 查看Docker磁盘使用docker system prune                 # 清理未使用的数据docker system prune -a              # 清理所有未使用的数据docker system prune --volumes       # 同时清理数据卷<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>资源清理</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker container prune              # 清理停止的容器docker image prune                  # 清理未使用的镜像docker volume prune                 # 清理未使用的数据卷docker network prune                # 清理未使用的网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十三、故障排查"><a href="#十三、故障排查" class="headerlink" title="十三、故障排查"></a>十三、故障排查</h2><ol><li><p><strong>容器调试</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker logs container_id            # 查看容器日志docker inspect container_id         # 查看容器详细信息docker exec -it container_id sh     # 进入容器shelldocker diff container_id            # 查看容器文件变化docker events                       # 查看Docker事件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>网络调试</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker network inspect bridge       # 查看网络详情docker exec container_id ping other_container  # 测试容器间连通性docker exec container_id nslookup other_container  # DNS解析测试<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>性能分析</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash">docker stats                        # 实时查看资源使用docker top container_id             # 查看容器进程docker inspect -f '&#123;&#123;.State.Pid&#125;&#125;' container_id  # 获取容器PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十四、安全最佳实践"><a href="#十四、安全最佳实践" class="headerlink" title="十四、安全最佳实践"></a>十四、安全最佳实践</h2><ol><li><p><strong>运行时安全</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 以只读模式运行容器docker run --read-only nginx# 限制容器capabilitiesdocker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx# 使用非root用户运行docker run --user=1000:1000 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>镜像安全</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 扫描镜像漏洞docker scan nginx:latest# 使用官方镜像或可信来源docker pull docker.io/library/nginx:latest# 签名验证docker trust inspect nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十五、常用技巧和别名"><a href="#十五、常用技巧和别名" class="headerlink" title="十五、常用技巧和别名"></a>十五、常用技巧和别名</h2><ol><li><p><strong>实用别名</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 添加到~/.bashrc或~/.zshrcalias dps='docker ps'alias dpsa='docker ps -a'alias di='docker images'alias drm='docker rm $(docker ps -aq)'alias drmi='docker rmi $(docker images -q)'alias dex='docker exec -it'alias dlog='docker logs -f'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>常用组合命令</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 停止所有容器docker stop $(docker ps -aq)# 删除所有停止的容器docker rm $(docker ps -aq -f status=exited)# 删除所有未打标签的镜像docker rmi $(docker images -f "dangling=true" -q)# 查看容器IP地址docker inspect -f '&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' container_id# 导出容器文件系统docker export container_id > container.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十六、Docker-Swarm集群管理"><a href="#十六、Docker-Swarm集群管理" class="headerlink" title="十六、Docker Swarm集群管理"></a>十六、Docker Swarm集群管理</h2><ol><li><p><strong>初始化和加入集群</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 初始化Swarm集群docker swarm init --advertise-addr 192.168.1.100# 获取加入tokendocker swarm join-token workerdocker swarm join-token manager# 加入集群docker swarm join --token SWMTKN-1-xxx 192.168.1.100:2377<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>服务管理</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 创建服务docker service create --name web --replicas 3 -p 80:80 nginx# 扩展服务docker service scale web=5# 更新服务docker service update --image nginx:1.21 web# 查看服务docker service lsdocker service ps web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="十七、实际应用示例"><a href="#十七、实际应用示例" class="headerlink" title="十七、实际应用示例"></a>十七、实际应用示例</h2><ol><li><p><strong>Web应用部署</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># 创建网络docker network create webapp-net# 运行数据库docker run -d \  --name db \  --network webapp-net \  -e MYSQL_ROOT_PASSWORD=secret \  -e MYSQL_DATABASE=webapp \  -v mysql-data:/var/lib/mysql \  mysql:5.7# 运行Web应用docker run -d \  --name webapp \  --network webapp-net \  -p 8080:80 \  -e DB_HOST=db \  -e DB_USER=root \  -e DB_PASSWORD=secret \  -e DB_NAME=webapp \  webapp:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>开发环境搭建</strong></p><pre class="line-numbers language-language-yaml"><code class="language-language-yaml"># docker-compose.ymlversion: '3'services:  frontend:    build: ./frontend    volumes:      - ./frontend:/app      - /app/node_modules    ports:      - "3000:3000"    command: npm start    backend:    build: ./backend    volumes:      - ./backend:/app    ports:      - "5000:5000"    environment:      - NODE_ENV=development    depends_on:      - db    db:    image: postgres:13    volumes:      - pgdata:/var/lib/postgresql/data    environment:      - POSTGRES_PASSWORD=secret      - POSTGRES_DB=myappvolumes:  pgdata:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>CI&#x2F;CD集成</strong></p><pre class="line-numbers language-language-bash"><code class="language-language-bash"># Jenkinsfile示例pipeline &#123;  agent &#123; docker &#123; image 'node:14' &#125; &#125;  stages &#123;    stage('Build') &#123;      steps &#123;        sh 'npm install'        sh 'npm run build'      &#125;    &#125;    stage('Test') &#123;      steps &#123;        sh 'npm test'      &#125;    &#125;    stage('Docker Build') &#123;      steps &#123;        sh 'docker build -t myapp:$&#123;BUILD_NUMBER&#125; .'      &#125;    &#125;    stage('Deploy') &#123;      steps &#123;        sh 'docker push myapp:$&#123;BUILD_NUMBER&#125;'      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Alibaba-Nacos</title>
      <link href="/2024/04/23/springcloud-alibaba-nacos/"/>
      <url>/2024/04/23/springcloud-alibaba-nacos/</url>
      
        <content type="html"><![CDATA[<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>Nacos 是由阿里巴巴开源的一个<strong>动态服务发现</strong>、<strong>配置</strong>和<strong>服务管理平台</strong>，专为微服务架构设计。它帮助开发者实现云原生应用的动态服务发现和配置管理，提供了轻量级的服务注册和发现机制以及动态的服务配置功能。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ol><li>服务发现与注册：<ul><li>Nacos 支持 DNS-based 和 RPC-based 服务发现，提供实时健康检查，确保服务的可用性。服务实例上线或下线时，Nacos 会自动处理服务列表，客户端通过订阅服务列表获取最新的服务实例信息。</li></ul></li><li>动态配置管理：<ul><li>Nacos 提供中心化的配置管理服务，允许动态地管理应用配置，而无需重启服务。它支持配置自动更新，服务在运行时可以根据配置变化进行自适应调整。</li></ul></li><li>服务元数据和流量管理：<ul><li>Nacos 支持存储服务的元数据，如权重、负载均衡策略等，这些元数据可以用于服务调度和流量管理。</li></ul></li><li>支持多种配置格式：<ul><li>Nacos 支持多种配置格式，包括但不限于 properties、YAML、JSON等。</li></ul></li><li>支持多种环境：<ul><li>Nacos 支持多环境、多租户的配置管理，助力于微服务的多环境隔离。</li></ul></li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>服务注册信息主要存储在服务器的内存中，以便快速响应服务发现的请求。这部分是服务注册的核心存储机制。</p><p>对于配置管理，Nacos 提供了两种存储方式：</p><ul><li><strong>内存中</strong>：为了快速访问，配置数据也会被缓存于内存中。</li><li><strong>持久化存储</strong>：在持久化模式下，Nacos 支持使用外部数据库来存储配置数据。</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h3 id="1、Nacos-是怎么发现新进来的微服务实例的？"><a href="#1、Nacos-是怎么发现新进来的微服务实例的？" class="headerlink" title="1、Nacos 是怎么发现新进来的微服务实例的？"></a>1、Nacos 是怎么发现新进来的微服务实例的？</h3><p>当一个微服务实例启动时，首先在 yml 文件中配置 Nacos 注册中心的地址，然后在启动类上添加服务发现 @EnableDiscoveryClient 注解。这样它会自动向 Nacos Server 注册当前服务实例。这个过程通常是通过调用 Nacos Server 的 API，将自己的服务名称、实例ID、IP地址、端口号等信息发送给 Nacos Server。注册成功之后，Nacos 并能感知到这个实例的存在。</p><h3 id="2、Nacos-是如何发现一个服务不可用的？"><a href="#2、Nacos-是如何发现一个服务不可用的？" class="headerlink" title="2、Nacos 是如何发现一个服务不可用的？"></a>2、Nacos 是如何发现一个服务不可用的？</h3><p>Nacos Server 会定时发送心跳检查请求到每一个已注册的服务实例，以确认它们是否还存活。如果在一定时间内（默认是30秒）没有收到某个服务实例的心跳响应，Nacos 会认为这个服务实例已经不可用，并将其从服务列表中剔除。</p><h3 id="3、当一个服务要调用另一个服务时，流程是哪样子的？"><a href="#3、当一个服务要调用另一个服务时，流程是哪样子的？" class="headerlink" title="3、当一个服务要调用另一个服务时，流程是哪样子的？"></a>3、当一个服务要调用另一个服务时，流程是哪样子的？</h3><ul><li>当服务 A 想要调用服务 B 时，服务 A 首先会向服务注册中心（Nacos）请求服务 B 的实例信息。</li><li>服务注册中心接收到响应，然后返回服务 B 所有可用实例列表给服务A。</li><li>服务 A 通过集成的客户端负载均衡器（如Ribbon），根据某种负载均衡策略（如轮询、随机、权重等）选择一个服务B的实例。</li><li>服务 A 通过选定的服务 B 实例的网络地址发起对服务 B 的调用。通常通过 HTTP 或其他 RPC 协议实现。</li><li>如果调用失败，服务A可以选择另一个服务B的实例进行重试。</li><li>被调用的服务 B 实例接收请求，处理业务逻辑，并返回响应给服务 A。</li></ul><h3 id="4、灰度发布和蓝绿部署是什么意思？"><a href="#4、灰度发布和蓝绿部署是什么意思？" class="headerlink" title="4、灰度发布和蓝绿部署是什么意思？"></a>4、灰度发布和蓝绿部署是什么意思？</h3><ul><li>灰度发布：是指新版本的服务逐渐替代旧版本的过程，初期只有少部分用户使用新版本，如果新版本稳定，再逐渐扩大到所有用户。这样可以确保新版本的稳定性，并减少因新版本引入的问题对所有用户的影响。</li><li>蓝绿部署：是指同时部署两个版本的服务，蓝色代表旧版本，绿色代表新版本。所有的流量首先路由到蓝色版本，当绿色版本准备好并经过测试后，流量可以切换到绿色版本。这样可以快速回滚到蓝色版本，如果绿色版本有问题。</li></ul><h3 id="5、Nacos-和-Gateway-之间是怎么样的关系？"><a href="#5、Nacos-和-Gateway-之间是怎么样的关系？" class="headerlink" title="5、Nacos 和 Gateway 之间是怎么样的关系？"></a>5、Nacos 和 Gateway 之间是怎么样的关系？</h3><ul><li>Nacos 主要负责<code>服务的注册与发现</code>以及<code>配置管理</code>。而Gateway 是<code>API网关</code>，负责处理外部请求并将其路由到相应的微服务。</li><li>当 Gateway 需要路由请求到某个服务时，它会向服务注册中心查询这个服务的实例列表，然后通过集成的负载均衡器，根据负载均衡策略选择一个实例进行调用。</li></ul><h3 id="6、Nacos-集群之间是怎么同步的？"><a href="#6、Nacos-集群之间是怎么同步的？" class="headerlink" title="6、Nacos 集群之间是怎么同步的？"></a>6、Nacos 集群之间是怎么同步的？</h3><p>Nacos 集群中的数据同步主要依靠 Raft 协议来保证一致性。这是一种分布式计算中用于实现多节点间一致性的协议，常用于多副本数据的一致性保障。</p><ol><li>领导选举（Leader Election）：<ul><li>当 Nacos 集群启动时，或者领导者节点失效时，集群会通过 Raft 协议进行新的领导者选举。</li><li>所有的写操作（比如更新配置信息或服务注册信息）都必须通过领导者来进行。</li></ul></li><li>日志复制（Log Replication）：<ul><li>当领导者节点接收到一个更新请求（比如配置更新或服务注册），它首先将这个请求作为一个新的日志条目添加到它的日志中。</li><li>然后，领导者将这个日志条目发送给其他的追随者节点。</li><li>追随者节点将该日志条目添加到它们各自的日志中，并向领导者确认接收成功。</li></ul></li><li>数据提交：<ul><li>一旦领导者节点从大多数追随者那里收到了确认，它就会提交该日志条目，并将更新应用到系统状态上。</li><li>领导者之后会通知追随者已经提交了哪些日志条目，追随者随后也会将这些条目提交并应用到各自的系统状态。</li></ul></li><li>读取操作：<ul><li>对于读操作，可以直接由任何一个节点处理，但为了保证读到的数据是最新的，通过读操作也会通过领导者节点来进行。</li></ul></li></ol><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP 理论指出，一个分布式系统不可能同时满足以下三点：</p><ul><li><strong>一致性（Consistency）</strong>：每次读取都能得到最新的写入或错误响应。</li><li><strong>可用性（Availability）</strong>：每次请求都能得到响应，无论成功或失败。</li><li><strong>分区容错性（Partition tolerance）</strong>：系统中任何信息的丢失或失败都不会影响系统的继续运行。</li></ul><h3 id="Nacos-的-CAP-配置"><a href="#Nacos-的-CAP-配置" class="headerlink" title="Nacos 的 CAP 配置"></a>Nacos 的 CAP 配置</h3><p>Nacos 提供了两种运行模式，可以根据需要在一致性和可用性之间进行选择，确保系统按需求正确运行：</p><p>在CAP理论中，Nacos可以配置为更偏向于“一致性（C）”和“分区容错性（P）”，也可以配置为更偏向于“可用性（A）”和“分区容错性（P）”，这取决于具体的使用场景和配置。</p><ul><li><p>不同的运行模式：</p><ul><li><p>AP 模式：</p><ul><li><p>当运行在 AP 模式下，Nacos 更偏向于高可用性和分区容错性。这在大多数服务发现场景是可取的，因为在这种情况下，即使在网络分区或部分系统故障的情况下，服务仍然需要被发现和消费。</p></li><li><p>在 AP 模式下，Nacos 可能会牺牲一致性来保证高可用性。也就是说，服务的注册和发现可能不会立即反映最新状态，但服务的发现和路由功能仍然是可用的。</p></li><li><p>作为服务注册中心：</p><ul><li>当Nacos用作服务注册中心时，它通常运行在AP模式。这是因为在服务发现的场景中，可用性和分区容错性通常被视为更重要。即使在网络分区或部分服务不可用的情况下，服务注册和发现功能仍然可以正常工作，尽管这可能会导致短暂的数据不一致。</li></ul></li></ul></li><li><p>CP 模式：</p><ul><li><p>当运行在 CP 模式下，Nacos 更注重一致性和分区容错性。这适用于配置管理场景，因为配置信息的正确性和一致性是非常重要的。</p></li><li><p>在 CP 模式下，Nacos 会确保配置的一致性，即使这可能意味着在网络分区或其他问题发生时，对配置的访问可能会受到影响。</p></li><li><p>作为配置中心：</p><ul><li>当Nacos用作配置中心时，它通常运行在CP模式。在配置管理场景下，一致性是非常关键的，因为配置信息需要在所有服务实例之间保持一致。Nacos 确保即使在网络分区或故障的情况下，所有服务实例也能获取到一致的配置信息。</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud Alibaba </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Ribbon</title>
      <link href="/2024/04/23/springcloud-ribbon/"/>
      <url>/2024/04/23/springcloud-ribbon/</url>
      
        <content type="html"><![CDATA[<p>Ribbon 是一个客户端负载均衡器，它可以在调用微服务时提供<strong>负载均衡</strong>的功能。在Spring Cloud 中，Ribbon 通常与 Eureka、Nacos 等其他服务发现组件结合使用，以实现在客户端进行服务的动态查找和负载均衡。Ribbon <strong>主要用于控制 HTTP 和 TCP 客户端的行为</strong>。</p><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ol><li><strong>服务发现集成</strong>：当 Ribbon 客户端启动时，它会从服务组件（如Eureka、Nacos等）获取可用的服务实例列表，并对这些实例进行负载均衡策略。</li><li><strong>负载均衡策略</strong>：Ribbon 内置了多种负载均衡策略，如<strong>轮询</strong>、<strong>随机</strong>、<strong>权重</strong>等（默认是轮询）。用户可以选择合适的策略，也可以自定义策略。</li><li><strong>容错机制</strong>：Ribbon 提供了失败重试机制，可以在调用失败时自动重试其他实例。这增加了调用的健壮性。</li><li><strong>客户端缓存和批处理</strong>：Ribbon 可以缓存客户端请求，支持请求的批量发送，优化网络使用等。</li><li><strong>可配置性</strong>：Ribbon 允许开发者通过配置文件定制和调整其行为，包括超时设置、重试策略、连接池大小等。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><strong>服务发现</strong>：首先从服务注册中心获取可用的服务实例列表。</li><li><strong>选择服务实例</strong>：根据配置的负载均衡策略，从可用服务实例中选择一个。</li><li><strong>服务调用</strong>：对选定的服务实例进行网络请求。</li><li><strong>错误处理和重试</strong>：在发生错误时，根据配置的策略进行重试或失败回退。</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>微服务间的调用</strong>：在微服务架构中，服务实例可能会动态地上下线，Ribbon可以帮助客户端自动发现可用的服务实例，并进行负载均衡。</li><li><strong>消除单点故障</strong>：通过Ribbon的负载均衡，请求可以被分散到多个服务实例，从而消除单点故障。</li><li><strong>通过系统吞吐量</strong>：通过将请求均匀分配到多个服务实例，可以提高系统的整体吞吐量。</li></ol><h3 id="故障处理：使用-Ribbon-的失败重试和回退机制"><a href="#故障处理：使用-Ribbon-的失败重试和回退机制" class="headerlink" title="故障处理：使用 Ribbon 的失败重试和回退机制"></a>故障处理：使用 Ribbon 的失败重试和回退机制</h3><p><strong>失败重试</strong>：</p><p>Ribbon 允许配置自动重试机制，这意味着当服务调用失败时，Ribbon 可以自动重新发送请求到同一个或不同的服务实例。这在临时网络问题或服务瞬时故障时特别有用。</p><p><strong>配置示例</strong>：</p><p>在<code>application.properties</code>文件中，可以设置重试次数和条件:</p><pre><code>ribbon:  MaxAutoRetries=1                 # 同一个服务实例的最大重试次数  MaxAutoRetriesNextServer=2       # 尝试另一个服务实例的最大重试次数  OkToRetryOnAllOperations=true    # 允许对所有请求操作进行重试</code></pre><p><strong>回退策略</strong>：</p><p>回退策略允许在调用失败时提供一个默认的响应，这通常通过集成 Hystrix 来实现。Hystrix 提供了断路器功能，当服务不可用时可以自动切换到预定义的回退逻辑。</p><p><strong>实现示例</strong>：</p><p>使用Hystrix 在 Ribbon 调用中添加回退逻辑，例如在使用 <code>RestTemplate</code>进行服务调用时：</p><pre class="line-numbers language-language-java"><code class="language-language-java">@Servicepublic class MyService &#123;    @Autowired    private RestTemplate restTemplate;    @HystrixCommand(fallbackMethod = "reliable")    public String getData(String serviceId) &#123;        return restTemplate.getForObject("http://" + serviceId + "/data", String.class);    &#125;    public String reliable(String serviceId) &#123;        return "Default Data";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="性能优化：调整-Ribbon-的性能设置"><a href="#性能优化：调整-Ribbon-的性能设置" class="headerlink" title="性能优化：调整 Ribbon 的性能设置"></a>性能优化：调整 Ribbon 的性能设置</h3><p>在使用 Ribbon 进行服务调用时，适当的性能优化可以提高响应速度和系统吞吐量。</p><p><strong>客户端超时设置</strong></p><p>调整请求超时设置可以防止服务调用过长时间等待，影响用户体验和资源使用效率。</p><pre><code>ribbon:  ReadTimeout=5000     # 读取超时时间（毫秒）  ConnectTimeout=1000  # 连接超时时间（毫秒）</code></pre><p><strong>请求批处理</strong></p><p>如果 Ribbon 用于大量的请求调用，可以采用请求批处理策略，合并短时间内的多个请求，减少网络往返次数，提高效率。</p><p><strong>连接池配置</strong></p><p>配置连接池可以重用 HTTP 连接，减少频繁建立连接的开销。</p><pre class="line-numbers language-language-java"><code class="language-language-java">@Beanpublic ClientHttpRequestFactory clientHttpRequestFactory() &#123;    HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();    factory.setReadTimeout(5000);    factory.setConnectTimeout(1000);    factory.setHttpClient(httpClient()); // 自定义配置 HttpClient    return factory;&#125;private HttpClient httpClient() &#123;    PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();    connectionManager.setMaxTotal(200);    // 最大连接数    connectionManager.setDefaultMaxPerRoute(50); // 每个路由的默认最大连接数    return HttpClientBuilder.create().setConnectionManager(connectionManager).build();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Alibaba-Sentinel</title>
      <link href="/2024/04/23/springcloud-alibaba-sentinel/"/>
      <url>/2024/04/23/springcloud-alibaba-sentinel/</url>
      
        <content type="html"><![CDATA[<p>Sentinel 是一个开源的流量控制组件，由阿里巴巴开源。它主要用于微服务的<strong>稳定性</strong>和<strong>可靠性</strong>保障，提供了丰富的功能来应对各种服务和应用的高可用需求。Sentinel 特别适合用来处理微服务架构中的<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统自适应保护</strong>等问题。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>流量控制：<ul><li>Sentinel 可以通过定义流量控制规则来限制访问频率，保护系统不被高流量压垮。这些规则可以基于QPS（每秒查询率）或并发线程数设置。</li></ul></li><li>熔断降级：<ul><li>在服务不稳定（如响应时间过长或异常率过高）时会自动进行熔断，快速返回错误响应或者调用回退逻辑，防止服务雪崩效应。</li></ul></li><li>系统自适应保护：<ul><li>根据系统的负载情况（如CPU使用率、总体平均响应时间等）自动调整流量控制规则，确保系统在安全的负载下运行。</li></ul></li><li>热点参数限流：<ul><li>支持对经常访问的“热点”数据进行流量控制，比如对热门商品的请求过于频繁时自动进行限流。</li></ul></li><li>实时监控和动态规则配置：<ul><li>Sentinel 提供了实时监控功能，可以实时观察系统的运行状态和规则的执行效果（流量、熔断、响应时间等信息）。同时，支持通过控制台动态修改流量控制规则，无需重启应用。</li></ul></li><li>规则的优先级：<ul><li>Sentinel 支持多种规则，如流量控制规则、降级规则、系统保护规则等。这些规则有不同的优先级，当多个规则同时触发时，高优先级的规则会先被执行。</li></ul></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>微服务流量控制</strong>：在微服务架构中，可以使用Sentinel对服务间的调用进行流量控制。</li><li><strong>API网关流量控制</strong>：在API网关中，可以使用Sentinel对外部的请求进行流量控制。</li><li><strong>分布式系统熔断降级</strong>：在分布式系统中，可以使用Sentinel对故障的服务进行熔断降级。</li><li><strong>系统负载保护</strong>：当系统的负载过高时，可以使用Sentinel进行流量控制，保护系统。</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><strong>流量控制</strong>：保护系统免受恶意攻击和流量峰值。</li><li><strong>熔断控制</strong>：在服务出现问题时，自动进行熔断降级，保护系统。</li><li><strong>系统负载保护</strong>：在系统负载过高时，自动进行流量控制，保护系统。</li><li><strong>实时监控</strong>：提供实时的监控和统计功能，帮助运维人员了解系统的状态。</li></ol><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>Sentinel 使用<code>滑动窗口算法</code>来统计请求的数量和响应时间。这使得 Sentinel 可以实时地获取系统的运行状态，并根据这些状态做出限流、降级和熔断的决策。</li><li>Sentinel 的核心是一系列的处理器和规则。处理器负载统计数据和执行控制逻辑，而规则定义了何时触发控制逻辑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud Alibaba </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Gateway</title>
      <link href="/2024/04/22/springcloud-gateway/"/>
      <url>/2024/04/22/springcloud-gateway/</url>
      
        <content type="html"><![CDATA[<p>Gateway是Spring Cloud的一个组件，用于构建API网关。API网关是微服务架构中的一个关键组件，它负责<strong>路由请求转发</strong>、<strong>负载均衡</strong>、<strong>断路器</strong>、<strong>安全</strong>、<strong>跨域</strong>、<strong>请求头</strong>和<strong>响应头的修改</strong>等。</p><h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><ul><li><strong>Routes</strong>：路由</li><li><strong>Filters</strong>：过滤器</li><li><strong>Predicates</strong>：断言</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><p><strong>路由</strong>：客户端向 Spring Cloud Gateway 发出请求后，Gateway Handler Mapping 查找与请求相匹配的路由。</p></li><li><p>过滤器</p><p>：在请求达到实际服务之前，Gateway 可以使用过滤器来修改传入的 HTTP 请求；同理，返回的 HTTP 响应也可以被过滤器处理。</p><ul><li>有两种类型的过滤器，<code>pre 过滤器</code>和<code>post 过滤器</code>。pre 过滤器在路由请求之前执行，post 过滤器在路由请求之后执行。</li></ul></li><li><p><strong>转发</strong>：最后请求将被转发到实际的服务。</p></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>路由和负载均衡</strong>：将请求路由到合适的微服务实例。</li><li><strong>安全</strong>：如身份验证和授权。</li><li><strong>限流</strong>：限制请求的速率。</li><li><strong>缓存</strong>：缓存请求的响应。</li><li><strong>断路</strong>：在某个微服务实例出现问题时，快速失败。</li><li><strong>跨域</strong>：处理跨域资源共享（CORS）请求。</li><li><strong>请求和响应的修改</strong>：如添加、删除或修改头信息。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>统一入口</strong>：为微服务提供一个统一的访问入口，简化客户端调用。</li><li><strong>安全防护</strong>：提供安全机制，如身份验证、授权和防止恶意攻击。</li><li><strong>性能优化</strong>：如负载均衡、缓存和限流。</li><li><strong>故障隔离</strong>：如断路和重试。</li></ul><h3 id="定义路由规则"><a href="#定义路由规则" class="headerlink" title="定义路由规则"></a>定义路由规则</h3><p>Gateway 使用一组路由规则来确定如何处理传入的 HTTP 请求。每条路由规则定义了一个<strong>目标</strong> URI 、一组<strong>断言</strong>和一组<strong>过滤器</strong>。当断言为真时，请求会被路由到目标 URI ，并在路由之前和之后应用过滤器。</p><p>在 application.yml 中：</p><pre><code>spring:  cloud:    gateway:      routes:      ## 路由规则的唯一标识符      - id: user-service        uri: lb://user-service        predicates:        - Path=/user/**        filters:        - AddRequestHeader=X-Request-Foo, Bar</code></pre><p>在 Spring Cloud Gateway 的路由定义中：</p><ul><li><p><strong>id</strong>：这是路由的唯一标识符。它用于区分和标识不同的路由规则。在管理、监控或日志中，这个<code>id</code>可以帮助我们快速识别和引用特定的路由。</p></li><li><p>uri</p><p>：这是路由的目标URI。当</p><p>请求满足某个路由的断言时，它会被转发到这个URI</p><p>。这个</p><pre><code>URI</code></pre><p>可以是一个具体的地址，也可以是一个服务的逻辑名称。</p><ul><li>当URI的前缀是 <code>lb://&#123;&#123;微服务名称&#125;&#125;</code> 时，表示这是一个逻辑地址，需要使用客户端负载均衡器（如 Ribbon）来解析。在这个例子中，<code>lb://user-service</code> 表示请求会被负载均衡到名为 <code>user-service</code> 的服务实例。</li><li>如果 URI 是一个 HTTP 或 HTTPS 地址，lb:&#x2F;&#x2F;<a href="https://www.baidu.com,那么请求会被直接转发到这个地/">https://www.baidu.com，那么请求会被直接转发到这个地</a></li></ul></li><li><p>predicates 路由谓词</p><p>：</p><ul><li><p>谓词用于匹配和过滤HTTP请求。</p></li><li><p>SpringCloud Gateway 提供了多种内置谓词，如：</p><ul><li><p>Path</p><p>：根据请求路径匹配。</p><ul><li><strong>Method</strong>：根据HTTP方法匹配。</li><li><strong>Header</strong>：根据请求头匹配。</li><li><strong>Query</strong>：根据查询参数匹配。</li></ul></li></ul></li></ul></li><li><p>filters 过滤器</p><p>：</p><ul><li>Gateway 提供了多种过滤器，这些过滤器分为全局过滤器和路由过滤器。全局过滤器对所有请求都有效，而路由过滤器只对特定的路由有效。</li><li>过滤器的执行顺序是由其 order 属性决定的。请求首先会经过所有的 pre 类型的过滤器，然后路由到下游服务，最后再经过所有的 post 类型的过滤器。</li></ul></li></ul><p>上述配置定义了一个路由规则，当请求的路径匹配 <code>/user/**</code> 断言时，它会被路由到名为 <code>user-service</code> 的微服务，并在请求头中添加一个名为 X-Request-Foo 的头信息。</p><h3 id="定义过滤器"><a href="#定义过滤器" class="headerlink" title="定义过滤器"></a>定义过滤器</h3><pre class="line-numbers language-language-java"><code class="language-language-java">@Beanpublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123;    return builder.routes()        .route("path_route", r -> r.path("/get")            .filters(f -> f.addRequestHeader("Hello", "World"))            .uri("<http://httpbin.org>"))        .build();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码定义了一个路由规则，当请求的路径为 &#x2F;get 时，它会被路由到 <a href="http://httpbin.org/get">http://httpbin.org/get</a> ，并在请求头中添加一个名为 Hello 的头信息。</p><h3 id="SpringCloud-Gateway的应用"><a href="#SpringCloud-Gateway的应用" class="headerlink" title="SpringCloud Gateway的应用"></a>SpringCloud Gateway的应用</h3><h3 id="1-动态路由"><a href="#1-动态路由" class="headerlink" title="1. 动态路由"></a>1. 动态路由</h3><ul><li>Gateway 支持动态路由，允许您在运行时添加、修改或删除路由规则。</li><li>这是通过与Spring Cloud Config 或其他外部配置源的集成来实现的。</li><li>当路由配置发生变化时，Gateway 可以自动刷新路由规则，而无需重新启动应用。</li></ul><h3 id="2-API聚合"><a href="#2-API聚合" class="headerlink" title="2. API聚合"></a>2. API聚合</h3><p>网关可以用来聚合多个后端服务的API调用结果。例如，客户端可以只发送一个请求到网关，网关则分别向多个服务发请求，然后将结果聚合后返回给客户端。这可以减少客户端与服务间的通信次数，并简化客户端逻辑。</p><h3 id="3-全局过滤器"><a href="#3-全局过滤器" class="headerlink" title="3. 全局过滤器"></a>3. 全局过滤器</h3><p>除了标准的路由过滤器外，Spring Cloud Gateway 还提供全局过滤器，它对所有的路由有效。这些全局过滤器可以用来实现跨服务的逻辑，如权限校验、日志跟踪记录、安全检查等。</p><h3 id="4-断路器集成"><a href="#4-断路器集成" class="headerlink" title="4. 断路器集成"></a>4. 断路器集成</h3><ul><li>Spring Cloud GateWay 支持与 Hystrix 断路器的集成。当某个下游服务出现问题时，断路器可以防止请求继续传递给服务，从而防止系统雪崩。</li><li>通过配置，你可以为特定的路由定义断路器的行为，例如失败的阈值和回退的响应。</li></ul><h3 id="5-重试机制"><a href="#5-重试机制" class="headerlink" title="5. 重试机制"></a>5. 重试机制</h3><ul><li>如果某个微服务实例失败，Gateway 可以配置为自动重试其他实例。</li><li>重试可以基于不同的策略，如固定延迟、指数退避等。</li><li>这增加了系统的弹性和可用性。</li></ul><h3 id="6-请求速率限制"><a href="#6-请求速率限制" class="headerlink" title="6. 请求速率限制"></a>6. 请求速率限制</h3><p>通过与Redis等技术的集成，Spring Cloud Gateway 支持对客户端请求进行速率限制，这有助于防止API滥用并保护后端服务免受过载。</p><ul><li>例如，你可以为特定的用户或IP设置每秒的请求限制。</li><li>限流可以帮助您保护系统免受恶意攻击和意外的流量峰值。</li></ul><h3 id="7-集成与第三方服务发现"><a href="#7-集成与第三方服务发现" class="headerlink" title="7. 集成与第三方服务发现"></a>7. 集成与第三方服务发现</h3><ul><li>Gateway 可以与Eureka、Consul、Zookeeper等服务发现组件集成。</li><li>当使用 <code>lb://&#123;&#123;微服务名称&#125;&#125;</code> 前缀的逻辑地址时，Gateway 会从服务发现组件中自动获取可用的服务实例，并进行负载均衡。</li></ul><h2 id="关于底层的负载均衡器"><a href="#关于底层的负载均衡器" class="headerlink" title="关于底层的负载均衡器"></a>关于底层的负载均衡器</h2><p>在Spring Cloud的较早版本中，<strong>Ribbon</strong>是默认的客户端负载均衡器。但从Spring Cloud Greenwich版本开始，官方推荐使用<strong>Spring Cloud LoadBalancer</strong>，这是一个基于Spring Reactor的新的轻量级、反应式负载均衡器。</p><p>Spring Cloud LoadBalancer的特点：</p><ul><li>它是一个反应式的负载均衡器，并且完全集成在WebFlux环境中。</li><li>提供了一个简单的轮询和随机负载均衡策略的默认实现，也支持自定义策略。</li><li>它使用了Spring Boot 2.x中引入的HttpClient或WebClient来进行实际的服务调用。</li></ul><p>虽然Ribbon项目现在处于维护模式，不再建议用于新的项目，但现有项目可以继续使用Ribbon而无需迁移到Spring Cloud LoadBalancer。</p><p>在实际的Spring Cloud项目中，你应该确保使用的是兼容的Spring Cloud版本，并且对应地选择使用Ribbon还是Spring Cloud LoadBalancer。如果你的Spring Cloud版本较新（比如Hoxton版本及以后），应该使用Spring Cloud LoadBalancer作为客户端负载均衡器。</p><p>总的来说，SpringCloud Gateway 是一个功能强大的API网关，它提供了一系列的工具和特性，使得开发者可以轻松地构建和管理微服务应用的API网关。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基础巩固</title>
      <link href="/2024/04/10/springboot/"/>
      <url>/2024/04/10/springboot/</url>
      
        <content type="html"><![CDATA[<h2 id="约定大于配置、自动配置"><a href="#约定大于配置、自动配置" class="headerlink" title="约定大于配置、自动配置"></a>约定大于配置、自动配置</h2><h3 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h3><p>SpringBoot采用了<strong>约定大于配置</strong>的原则，这意味着如果你遵循某些默认的约定（例如，将数据库配置放在特定的位置），SpringBoot 会为你自动配置大部分的应用设置。这大大减少了配置的需求和可能出错的地方。</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a><strong>自动配置</strong></h3><p>SpringBoot可以根据你的项目中的jar依赖自动配置你的应用。例如，如果你的项目中有<strong>spring-boot-start-web</strong>依赖，SpringBoot会认为你想创建一个Web应用，并自动为你配置 Tomcat 和 SpringMVC。</p><h3 id="工作流程简述"><a href="#工作流程简述" class="headerlink" title="工作流程简述"></a><strong>工作流程简述</strong></h3><ol><li><p>应用启动时，</p><pre><code>@SpringBootApplication</code></pre><p>注解中的</p><pre><code>@EnableAutoConfiguration</code></pre><p>注解激活自动配置机制。</p><ol><li>SpringBootApplication 是一个组合注解，里面包含了 <code>@Configuration</code>、<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>。</li></ol></li><li><p>Spring Boot会读取所有<code>META-INF/spring.factories</code>文件，查找并加载所有指定的自动配置类。</p></li><li><p>自动配置类会根据条件注解（如<code>@ConditionalOnClass</code>等）判断条件是否满足，决定是否执行相应的自动配置逻辑。</p></li><li><p>自动配置类会被加载到Spring容器中，提供所需要的bean实例，完成自动配置。</p></li></ol><h3 id="SpringBoot-中常用的注解"><a href="#SpringBoot-中常用的注解" class="headerlink" title="SpringBoot 中常用的注解"></a><strong>SpringBoot 中常用的注解</strong></h3><ol><li><p>@SpringBootApplication</p><p>：复合注解，包括 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan。</p><ul><li>它标记一个类作为 SpringBoot 应用的主配置类。</li></ul></li><li><p>@EnableAutoConfiguration</p><p>：告诉 SpringBoot 启动自动配置</p><ul><li>它会尝试根据添加的 jar 依赖自动配置应用。</li></ul></li><li><p>@ConfigurationProperties</p><p>：用于配置文件中的属性绑定到一个 Java 对象</p><ul><li>例如，可以将 application.properties 或 application.yml 中的属性绑定到一个 Bean。</li></ul></li><li><p>@ComponentScan</p><p>：Spring 会自动扫描指定包下的所有组件、配置类和服务。</p><ul><li>通常与 @SpringBootApplication 搭配使用</li></ul></li><li><p>@Bean</p><p>：用于标记一个方法为 Bean 的生产者。</p><ul><li>该方法的返回值会被添加到 Spring 上下文中。</li></ul></li><li><p><strong>@Value</strong>：用于将配置文件中的一个属性值注入到Bean属性中。</p></li><li><p>@RestController</p><p>：是一个复合注解，它包括 @Controller 和 @ResponseBody。</p><ul><li>用于创建 RESTful Web 服务。</li></ul></li><li><p>@RequestMapping</p><p>：用于定义 URL 映射和 HTTP 操作类型（如GET、POST）。</p><ul><li>可以在类或方法上使用。</li></ul></li><li><p><strong>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping</strong>：这些是@RequestMapping的特定快捷方式，用于处理特定的HTTP操作。</p></li><li><p>@PathVariable</p><p>：用于从 URL 模板中提取值。</p><ul><li>例如，在 @GetMapping(“&#x2F;users&#x2F;{id}”) 中提取 id。</li></ul></li><li><p>@RequestParam</p><p>：用于从请求参数中提取值。</p><ul><li>例如，在查询参数 ?name&#x3D;value 中提取 name。</li></ul></li><li><p>@Autowired</p><p>：用于自动注入 Bean。</p><ul><li>Spring 会查找并注入匹配的 Bean。</li></ul></li><li><p>@Service, @Repository, @Controller, @Component</p><p>：这些注解用于定义 Bean，并告诉 Spring 这些类是 Spring 组件。</p><ul><li>Spring 会自动检测并注册这些组件。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础巩固</title>
      <link href="/2024/04/08/spring/"/>
      <url>/2024/04/08/spring/</url>
      
        <content type="html"><![CDATA[<p>Spring 框架是 Java 开发中最流行的框架之一，它提供了全面的基础设施支持，使得开发者可以轻松构建企业级应用程序。</p><h2 id="IOC（Inversion-of-Control）"><a href="#IOC（Inversion-of-Control）" class="headerlink" title="IOC（Inversion of Control）"></a>IOC（Inversion of Control）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>IoC 即控制反转，是一种设计原则，它将应用程序的控制权从程序代码本身转移到外部容器或框架中。传统的程序设计中，程序内部直接控制程序流程和对象的创建与销毁，而在IoC中，对象的创建和管理由容器来完成，应用程序只需要描述组件之间的依赖关系，而不需要负责对象的创建和销毁。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>IoC 的主要作用在于降低了组件之间的耦合度，使得应用程序更加灵活、可扩展和易于维护。通过将对象的创建和管理交给容器，我们可以更容易地替换、扩展和重用组件，同时也能更好地实现面向接口编程。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>IoC的实现原理主要通过依赖注入（Dependency Injection）来实现。依赖注入是IoC的一种具体实现方式，它通过容器来动态地将组件之间的依赖关系注入到组件中，从而实现控制反转。</p><p>依赖注入有三种主要的方式：</p><p>构造器注入(需要结合@Configuration来使用)</p><ul><li>通过构造函数来注入依赖对象。</li><li><strong>优势</strong>：明确表明了类的依赖关系，使得类的依赖关系更加明确和可见。</li><li><strong>劣势</strong>：当类有多个依赖关系时，构造函数的参数列表可能变得很长，增加了代码的复杂性。</li></ul><pre class="line-numbers language-language-java"><code class="language-language-java"> private final UserRepository userRepository;    // 构造器注入    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;        ...        @Configuration    public class AppConfig &#123;    @Bean    public UserRepository userRepository() &#123;        return new UserRepository();    &#125;    @Bean    public UserService userService(UserRepository userRepository) &#123;        return new UserService(userRepository);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Setter注入（需要结合**@Autowired来使用**）</p><ul><li>通过Setter方法来注入依赖对象。</li><li>优劣势：同上</li></ul><pre class="line-numbers language-language-java"><code class="language-language-java">    private UserRepository userRepository;    // Setter注入    public void setUserRepository(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字段注入</p><ul><li>通过字段直接注入依赖对象。</li><li><strong>优势</strong>：简洁明了，不需要额外的构造函数或Setter方法。</li><li><strong>劣势</strong>：对象的依赖关系被直接暴露在类的字段中，降低了类的封装性。</li></ul><pre class="line-numbers language-language-java"><code class="language-language-java">    @Autowired    private UserRepository userRepository;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>控制层&#x2F;服务层的依赖注入</li><li>数据访问层与业务逻辑层的解耦</li><li>组件的替换和扩展</li></ul><h2 id="AOP（Aspect-Oriented-Programming）"><a href="#AOP（Aspect-Oriented-Programming）" class="headerlink" title="AOP（Aspect-Oriented Programming）"></a>AOP（Aspect-Oriented Programming）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>AOP 即面向横面编程，是一种编程范式，它允许将横切关注点（cross-cutting concerns）从业务逻辑中分离出来，将它们定义为独立的模块，然后以声明的方式将这些模块应用到多个不同的组件中。这样做的目的是提高代码的重用性、可维护性和可扩展性。</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>AOP 的作用在于解决了重复性代码的问题，将横切关注点（如日志记录、事务管理、安全检查等）与核心业务逻辑分离开来，使得代码更加模块化、清晰可读。</p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>在Spring中，AOP主要通过动态代理实现，具体而言有两种主要的实现方式：JDK动态代理和CGLIB动态代理。</p><ol><li><p><strong>JDK 动态代理：</strong></p><ul><li>JDK 动态代理是基于接口（UserService）的代理，它要求目标类（UserServiceImpl）必须实现一个接口。</li><li>当目标类实现了接口时，Spring 容器会自动使用 JDK 动态代理生成一个实现了该接口（UserService）的代理类，并在代理类中织入切面逻辑。</li><li>JDK 动态代理通过  <strong><code>java.lang.reflect.Proxy</code></strong> 类和 <strong><code>java.lang.reflect.InvocationHandler</code></strong> 接口来实现。</li></ul><pre class="line-numbers language-language-java"><code class="language-language-java">public interface UserService &#123;    void addUser(String username);&#125;public class UserServiceImpl implements UserService &#123;    @Override    public void addUser(String username) &#123;        // 添加用户逻辑...        System.out.println("User added: " + username);    &#125;&#125;public class LoggingAspect implements InvocationHandler &#123;    private Object target;    public LoggingAspect(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println("Before calling method: " + method.getName());        Object result = method.invoke(target, args);        System.out.println("After calling method: " + method.getName());        return result;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        UserService target = new UserServiceImpl();        LoggingAspect loggingAspect = new LoggingAspect(target);        UserService proxy = (UserService) Proxy.newProxyInstance(                target.getClass().getClassLoader(),                target.getClass().getInterfaces(),                loggingAspect);        proxy.addUser("Alice");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先定义了一个 <strong><code>UserService</code></strong> 接口，其中包含了一个 <strong><code>addUser</code></strong> 方法用于添加用户。然后，我们创建了一个 <strong><code>UserServiceImpl</code></strong> 类来实现这个接口，其中实现了 <strong><code>addUser</code></strong> 方法。</p><p>接着，我们创建了一个名为 <strong><code>LoggingAspect</code></strong> 的日志记录类，实现了 <strong><code>InvocationHandler</code></strong> 接口。在这个类中，我们实现了 <strong><code>invoke</code></strong> 方法，该方法会在代理对象调用任何方法时被调用。在 <strong><code>invoke</code></strong> 方法中，我们首先记录了目标方法调用前的日志，然后调用目标方法，最后记录了目标方法调用后的日志。</p><p>在 <strong><code>Main</code></strong> 类中，我们首先创建了一个 <strong><code>UserService</code></strong> 的实例 <strong><code>target</code></strong>，然后将这个实例传递给 <strong><code>LoggingAspect</code></strong> 的构造函数创建了一个 <strong><code>LoggingAspect</code></strong> 的实例 <strong><code>loggingAspect</code></strong>。接着，我们使用 <strong><code>Proxy.newProxyInstance</code></strong> 方法为 <strong><code>UserService</code></strong> 接口创建了一个代理对象 <strong><code>proxy</code></strong>，并将 <strong><code>loggingAspect</code></strong> 设置为代理对象的调用处理器。最后，我们调用了 <strong><code>proxy</code></strong> 的 <strong><code>addUser</code></strong> 方法。</p></li><li><p>CGLIB 动态代理：</p><ul><li>CGLIB 动态代理是基于继承的代理，它不要求目标必须实现接口。</li><li>当目标类没有实现接口时，Spring 容器会自动使用CGLIB动态代理生成一个目标类的子类，并在子类中织入切面逻辑。</li><li>CGLIB 动态代理通过字节码增强技术来实现。</li></ul><pre class="line-numbers language-language-java"><code class="language-language-java">public class UserService &#123;    public void addUser(String username) &#123;        // 添加用户逻辑...        System.out.println("User added: " + username);    &#125;&#125;public class LoggingAspect implements MethodInterceptor &#123;    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;        System.out.println("Before calling method: " + method.getName());        Object result = proxy.invokeSuper(obj, args);        System.out.println("After calling method: " + method.getName());        return result;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(UserService.class);        enhancer.setCallback(new LoggingAspect());        UserService proxy = (UserService) enhancer.create();        proxy.addUser("Alice");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>在Spring中，@Aspect 注解标记一个类后，Spring 会将其视为<strong>切面类</strong>，并在运行时自动为该类创建代理类对象，并将切面逻辑织入到代理对象中。就可以实现手动创建代理对象相似的功能，但更加简介和方便。</p><p>通过使用注解 @Aspect ，Spring 提供了一种声明式的方式来定义切面，并在AOP中应用它们，而无需手动编写代理逻辑和切面逻辑的代码。</p><ul><li><strong>@Before</strong>：在目标方法执行前执行切面逻辑。</li><li><strong>@After</strong>：在目标方法执行后（无论是否发生异常）执行切面逻辑。</li><li>@AfterReturing：在目标方法正常返回后执行切面逻辑。</li><li>@AfterThrowing：在目标方法抛出异常后执行切面逻辑。</li><li>@Around：在目标方法执行前后，控制目标方法的执行过程，可以自定义是否执行目标方法、执行前后的额外逻辑等。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>访问控制</strong>：通过 AOP，可以很容易地实现安全性控制功能，如登录认证和权限检查、IP黑名单。</li><li><strong>监控和日志记录</strong>：AOP 可以用于监控应用程序允许状况，如统计访问次数、计算执行时间开销等等。</li><li><strong>全局异常处理</strong>：通过 AOP 可以轻松捕获和处理全局异常，而不是单独在每个方法中进行处理。</li><li><strong>数据校验</strong>：AOP 可以用于在数据进入应用程序之前对其进行校验，确保输入的有效性。</li></ul><p><strong>题外话</strong>：</p><p><strong><code>@ExceptionHandler</code></strong> 和 <strong><code>@ControllerAdvice</code></strong> 并不是严格意义上的 AOP（面向切面编程）的一部分，而是 Spring MVC 中的一种异常处理机制。虽然它们在某种程度上类似于 AOP，但它们更多地是关于异常处理的技术，而不是切面的概念。</p><p><strong><code>@ExceptionHandler</code></strong> 用于在控制器内部处理单个请求处理方法中抛出的异常，而 <strong><code>@ControllerAdvice</code></strong> 则用于集中处理应用程序中的异常，它通常与 <strong><code>@ExceptionHandler</code></strong> 结合使用来处理全局异常。</p><p>虽然 <strong><code>@ExceptionHandler</code></strong> 和 <strong><code>@ControllerAdvice</code></strong> 可以看作是一种通过注解来实现的切面功能，但它们更多地是针对异常处理的，而不是通常意义上的 AOP，它们不是通过动态代理来实现的。</p><h2 id="Spring-的启动流程"><a href="#Spring-的启动流程" class="headerlink" title="Spring 的启动流程"></a>Spring 的启动流程</h2><h3 id="启动Spring应用加载上下文"><a href="#启动Spring应用加载上下文" class="headerlink" title="启动Spring应用加载上下文"></a>启动Spring应用加载上下文</h3><ul><li><strong>初始化 SpringApplication 对象</strong>：运行 SpringApplication(…)，加载 Application 应用上下文。</li></ul><h3 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h3><ul><li><strong>加载配置文件</strong>：读取配置文件，如 <a href="http://application.properties/">application.properties</a> 或 application.yml</li></ul><h3 id="注册和加载Bean"><a href="#注册和加载Bean" class="headerlink" title="注册和加载Bean"></a>注册和加载Bean</h3><ul><li><strong>注册和加载Bean</strong>：通过@ComponentScan 注解扫描类路径下的组件，如 @Service、@Repository、@Controller 等注解，将它们作为 Bean 注册并加载到 Bean 容器中。</li></ul><h3 id="BeanFactory-准备"><a href="#BeanFactory-准备" class="headerlink" title="BeanFactory 准备"></a>BeanFactory 准备</h3><ul><li><strong>初始化 BeanFactory</strong>：配置 Bean 工厂，并加载 Bean 定义。</li></ul><h3 id="初始化-Bean"><a href="#初始化-Bean" class="headerlink" title="初始化 Bean"></a>初始化 Bean</h3><ul><li>对于每个 Bean 进行实例化、依赖注入、属性配置，并调用初始化方法等。</li></ul><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><ul><li><strong>完成Bean 初始化</strong>：确保所有相关的 Bean 都已经创建并初始化。</li></ul><h3 id="就绪运行"><a href="#就绪运行" class="headerlink" title="就绪运行"></a>就绪运行</h3><ul><li>应用完全启动并就绪，可以接收服务请求。</li></ul><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><h3 id="实例化-Bean"><a href="#实例化-Bean" class="headerlink" title="实例化 Bean"></a>实例化 Bean</h3><ul><li><strong>通过构造器创建 Bean 实例（尚未填充属性）</strong>。</li></ul><h3 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h3><ul><li><strong>Spring 注入属性值和 Bean 引用</strong>。</li></ul><h3 id="调用-Bean-名称感知方法"><a href="#调用-Bean-名称感知方法" class="headerlink" title="调用 Bean 名称感知方法"></a>调用 Bean 名称感知方法</h3><ul><li><strong>如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName 方法</strong>。</li></ul><h3 id="调用-Bean-工厂感知方法"><a href="#调用-Bean-工厂感知方法" class="headerlink" title="调用 Bean 工厂感知方法"></a>调用 Bean 工厂感知方法</h3><ul><li><strong>如果 Bean 实现了 BeanFactoryAware 接口，Spring 调用 setBeanFactory 方法，传入 BeanFactory</strong>。</li></ul><h3 id="调用-ApplicationContext-感知"><a href="#调用-ApplicationContext-感知" class="headerlink" title="调用 ApplicationContext 感知"></a>调用 ApplicationContext 感知</h3><ul><li><strong>对于实现了 ApplicationContextAware 的 Bean，调用 setApplicationContext 方法</strong></li></ul><h3 id="前置处理器"><a href="#前置处理器" class="headerlink" title="前置处理器"></a>前置处理器</h3><ul><li><strong>BeanPostProcessor 的 postProcessBeforeInitialization 方法被调用</strong></li></ul><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul><li><strong>如果 Bean 实现了 InitializingBean 接口，调用 afterPropertiesSet 方法</strong></li><li><strong>如果 Bean 在 XML 中声明了 init-method，调用指定的方法</strong></li></ul><h3 id="后置处理器"><a href="#后置处理器" class="headerlink" title="后置处理器"></a>后置处理器</h3><ul><li><strong>BeanPostProcessor 的 postProcessAfterInitialization 方法被调用</strong></li></ul><h3 id="Bean准备就绪"><a href="#Bean准备就绪" class="headerlink" title="Bean准备就绪"></a>Bean准备就绪</h3><ul><li><strong>此时 Bean 已经准备好并可以被应用程序使用了</strong>。</li></ul><h3 id="销毁-Bean"><a href="#销毁-Bean" class="headerlink" title="销毁 Bean"></a>销毁 Bean</h3><ul><li><strong>如果 Bean 实现了 DisposableBean 接口，调用 destroy 方法</strong>。</li><li><strong>如果 Bean 在 XML 中声明了 destroy-method，调用指定的方法</strong>。</li></ul><h2 id="Spring-加载-Bean的-方式"><a href="#Spring-加载-Bean的-方式" class="headerlink" title="Spring 加载 Bean的 方式"></a>Spring 加载 Bean的 方式</h2><ol><li>基于 XML 的配置</li><li>基于注解的配置</li><li>配置类（@Configuration + @Bean）</li><li>通过 FactoryBean</li></ol><h2 id="Spring-的-bean-为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响"><a href="#Spring-的-bean-为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响" class="headerlink" title="Spring 的 bean 为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响"></a>Spring 的 bean 为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响</h2><p>Spring 框架中Bean的默认作用域是<code>单例（singleton）</code>，这是出于以下几个原因：</p><ol><li><strong>性能优化</strong>：创建对象通常是一个昂贵的过程，尤其是涉及到 I&#x2F;O 操作（如数据库连接）时。使用单例可以减少对象创建的次数，节省资源和提升性能。</li><li><strong>状态共享</strong>：单例模式允许在应用的不同部分共享同一个 Bean 实例，这对于状态共享和管理非常有用。</li><li><strong>资源管理</strong>：许多 Bean ，如数据源、会话工厂等，是自然的单例，因为它们封装了共享资源，如数据库连接池。</li></ol><p>除了单例模式，Spring 还提供其他几种 Bean 的作用域：</p><ul><li><strong>单例（Singleton）</strong>：在 Spring IoC 容器仅存在一个 Bean 实例，Bean 以单例方式存在。</li><li><strong>原型（prototype）</strong>：每次注入或通过 Spring 容器的 getBean() 请求时，都会创建一个新的Bean实例（这种模式就是多例）。</li><li><strong>请求（request）</strong>：每个 HTTP 请求都会创建一个新的 Bean ，该作用域仅在请求的处理过程中有效。</li><li><strong>会话（session）</strong>：在一个 HTTP 会话中，一个 Bean 定义对应一个 Bean 实例，该作用域同样仅在会话期间中有效。</li><li><strong>应用（application）</strong>：在一个 ServletContext 的生命周期内，一个 Bean 定义对应一个 Bean 实例，同样仅在 Web 应用的生命周期中有效。</li></ul><p>如果将 Bean 定义为多例（prototype）作用域，将会有以下影响：</p><ol><li><strong>资源使用增加</strong>：每次请求 Bean 时都会创建新实例，会增加内存和资源的使用。</li><li><strong>状态管理</strong>：多例 Bean 不会共享状态，每个 Bean 实例都有自己的状态。</li><li><strong>生命周期管理</strong>：Spring 不会管理 prototype Bean 的完整生命周期，也就是说，Spring 不会调用 prototype Bean 的销毁方法。</li><li><strong>复杂性增加</strong>：在使用多例 Bean 时，需要更加小心地管理其生命周期和依赖关系。</li></ol><p>总的来说，选择正确的作用域取决于具体的应用需求。单例作用域适合于<strong>需要共享状态的全局资源</strong>，而原型作用域<strong>适合于那些具有独立状态、生命周期较短或需要隔离的Bean、每次都需要一个新实例的情况</strong>。</p><h2 id="Spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h2><p>循环依赖是指两个或多个Bean相互依赖对方，形成了一个闭环。在Spring中，循环依赖主要发生在单例Bean之间。Spring通过<code>三级缓存机制</code> 来解决Bean的循环依赖问题，Spring 的三级缓存是 <code>为了处理Bean对象在不同状态下的存储</code> 。</p><h3 id="三级缓存机制"><a href="#三级缓存机制" class="headerlink" title="三级缓存机制"></a>三级缓存机制</h3><p><strong>一级缓存（Singleton Objects）：</strong></p><ul><li>用于存储完全初始化好的Bean实例，这些Bean已经被创建且注入了依赖，可以直接使用。</li></ul><p><strong>二级缓存（Early Singleton Objects）：</strong></p><ul><li>存储已经实例化好但还没有完全初始化的 Bean，这些 Bean 实例已经存在，但还没有完全依赖注入和初始化。</li></ul><p><strong>三级缓存（Singleton Factories）：</strong></p><ul><li>存储用于生成 Bean 的工厂对象，这些工厂对象可以生成 Bean 的早期引用，以解决循环依赖问题。</li></ul><p><strong>三级缓存的联系</strong></p><p>三级缓存是相互关联的，特别是在处理循环依赖的时候。当创建一个 Bean 时，Spring 可能需要从这些缓存中检索或移动 Bean，以确保正确的创建和初始化。</p><p><strong>Bean 的初始化与三级缓存的作用</strong></p><ol><li><p>实例化 Bean：</p><ul><li>首先，Spring 容器创建bean的实例。这一步通常是通过调用构造函数完成的。</li></ul></li><li><p>三级缓存（Singleton Factories）的使用：</p><ul><li>如果在bean的创建过程中检测到潜在的循环依赖，Spring会将一个能够生成bean的工厂对象放入三级缓存中。</li></ul></li><li><p>二级缓存（Early Singleton Objects）的使用：</p><ul><li>通过工厂对象生成的早期对象bean，在bean的进一步初始化（如依赖注入）之前，将bean被放入二级缓存中。此时，bean还未完全配置（如依赖注入和初始化回调可能尚未应用）。</li></ul></li><li><p>完成依赖注入和初始化：</p><ul><li>接下来，Spring 容器对bean进行依赖注入，并执行相关的初始化方法（如那些标注了**<code>@PostConstruct</code><strong>的方法或实现了</strong><code>InitializingBean</code><strong>接口的</strong><code>afterPropertiesSet</code>**方法）。</li></ul></li><li><p>移动到一级缓存（Singleton Objects）：</p><ul><li>一旦bean被完全初始化，它就从二级缓存中移除，并存放到一级缓存中。此时，bean已经完全准备好，可以被应用中的其他部分使用。</li></ul><h3 id="BeanFactory-和-ApplicationContext-的区别"><a href="#BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="BeanFactory 和 ApplicationContext 的区别"></a>BeanFactory 和 ApplicationContext 的区别</h3><p>BeanFactory 和 ApplicationContext 是 Spring 两个核心接口，都可以用来获取 Bean 实例，但在功能上有所不同。</p><ul><li>BeanFactory<ul><li><strong>提供了基本的依赖注入支持</strong>。</li><li><strong>延迟加载，只有在明确请求时才初始化Bean</strong>。</li></ul></li><li>ApplicationContext<ul><li><strong>完全初始化所有单例Bean</strong>。</li><li><strong>支持国际化（i18n）、事件传播、资源加载等</strong>。</li><li><strong>提供了AOP功能</strong>。</li><li><strong>通常在应用程序中使用 ApplicationContext</strong>。</li></ul></li></ul><h3 id="为什么在对应的-service-和-controller-标注了-Service-和-RestController-注解之后，Spring-容器就能够扫描到呢"><a href="#为什么在对应的-service-和-controller-标注了-Service-和-RestController-注解之后，Spring-容器就能够扫描到呢" class="headerlink" title="为什么在对应的 service 和 controller 标注了 @Service 和 @RestController 注解之后，Spring 容器就能够扫描到呢?"></a><strong>为什么在对应的 service 和 controller 标注了 @Service 和 @RestController 注解之后，Spring 容器就能够扫描到呢?</strong></h3><blockquote><p>答：之所以Spring容器能够扫描到这些容器，是因为@ComponentScan注解，该注解会扫描所有带有 @Component、@Service、@Repository、@Controller等注解的类，并未它们创建相对应的 Spring bean，随后这些 bean 可以通过依赖注入被其他部分所使用。所以当标注了@Service、@Controller等注解之后，Spring容器就会自动注册这些类，并在需要时创建它们的bean实例。</p></blockquote><p><strong>为什么在 service 的实现类 serviceimpl 标记了 @service 注解，在 controller 层只要注入 service 就可以引用serviceimpl 里面实现的功能呢？</strong></p><p>答：这里面涉及到了 入**<code>自动装配</code>**的知识点。</p><h3 id="自动装配的过程"><a href="#自动装配的过程" class="headerlink" title="自动装配的过程"></a><strong>自动装配的过程</strong></h3><ul><li><strong>搜索过程</strong>：当**<code>@Autowired</code><strong>用于注入</strong><code>Service</code><strong>接口时，Spring查找所有可用的</strong><code>Service</code><strong>类型的Bean。如果找到了与依赖类型兼容的Bean（实现了Service接口的impl类），Spring就会自动将其注入到声明了</strong><code>@Autowired</code>**的地方。</li><li><strong>冲突解决</strong>：如果存在多个匹配的Bean，Spring将需要额外的配置来选择使用哪一个，例如通过**<code>@Primary</code><strong>注解标注首选的Bean，或者使用</strong><code>@Qualifier</code>**注解指定注入哪一个特定的Bean。</li></ul><h3 id="By-Type-和-By-Name-的区别"><a href="#By-Type-和-By-Name-的区别" class="headerlink" title="By Type 和 By Name 的区别"></a>By Type 和 By Name 的区别</h3><p><strong>@Autowired 基于类型的依赖注入（By Type）</strong>：</p><ul><li><p><strong>定义</strong>：在基于类型的注入中，Spring 容器使用要注入的属性或构造函数参数的类型来在容器中查找匹配的 Bean。</p></li><li><p>代码示例：</p><pre class="line-numbers language-language-java"><code class="language-language-java">@Autowiredprivate MyService myService;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个例子中，Spring 会在其容器中查找 MyService 类型的 Bean，并进行注入。</p><p><strong>多个候选 Bean</strong>：如果存在多个同类型的 Bean，而没有其他限定信息，Spring 将无法决定使用哪一个，从而导致异常。这种情况下，可以使用 @Qualifier 注解来指定 Bean 的名称。</p></li></ul><p><strong>@Autowired基于名称的依赖注入（By Name）</strong>：</p><p><strong>定义</strong>：虽然**<code>@Autowired</code><strong>本身不提供直接的基于名称的注入，通过与</strong><code>@Qualifier</code><strong>结合使用，它可以非常灵活地实现</strong><code>基于名称的注入</code>**相似的功能。</p><p><strong>代码示例</strong>：</p><pre class="line-numbers language-language-java"><code class="language-language-java">@Autowired@Qualifier("mySpecificService")private MyService myService;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-java"><code class="language-language-java">@Service("mySpecificService")public class MyServiceImpl implements MyService &#123;    // 实现细节&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，Spring 会在其容器中查找名为 <code>mySpecificService</code> 的Bean来注入。</p><p><strong>@Resource 基于名称的依赖注入（By Name）（默认）</strong></p><p><strong>定义</strong>：**<code>@Resource</code>**注解是基于 JSR-250 标准，它可以根据名称或类型来注入依赖。 <strong>代码示例</strong>：</p><pre class="line-numbers language-language-java"><code class="language-language-java">@Resource(name = "mySpecificService")private MyService myService;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个例子中，**<code>@Resource</code><strong>注解通过</strong><code>name</code>**属性直接指定了要注入的 Bean 名称，从而实现了基于名称的注入。 <strong>@Resource 基于类型的依赖注入（By Type）</strong></p><pre class="line-numbers language-language-java"><code class="language-language-java">@Resourceprivate MyService myService;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>基于类型</strong>的注入更常见，它强调了类型的兼容性和接口编程的原则，适用于大多数情况，尤其是当每个类型只有一个Bean实例时。</li><li><strong>基于名称</strong>的注入在需要从多个同类型的Bean中选择特定一个时非常有用，它提供了更精确的控制，但牺牲了一些类型安全性。</li></ul><p>在Spring中，事务管理是非常关键的一部分，但是在使用过程中，有时候事务会失效。事务失效的原因可能有很多，以下是一些常见的原因：</p><p>确保方法是public的。 确保使用了Spring管理的事务注解或配置。 确保正确配置了事务管理器和数据源。 避免在同一个类中进行内部方法调用。 确保异常处理符合事务管理的要求。</p><ul><li>方法不是public的：Spring的事务管理默认是基于AOP（Aspect-Oriented Programming）的，只有public方法才能被代理。因此，如果事务方法不是public的，事务将不会生效。</li><li>方法内部调用：如果在同一个类中，一个非事务方法调用了一个事务方法，事务将不会生效。这是因为Spring AOP代理机制在内部方法调用时不会创建代理对象。解决方法是将事务方法提取到另一个类中，或者使用AspectJ进行事务管理。</li><li>没有使用Spring管理的事务注解或配置：确保你在配置文件或类中正确使用了@Transactional注解，或者在XML配置中正确定义了事务管理。</li><li>异常未被捕获或未被正确抛出：默认情况下，Spring只会在RuntimeException和Error子类异常时回滚事务。如果你捕获了异常或者抛出了检查异常（Checked Exception），事务可能不会回滚。可以通过rollbackFor属性指定需要回滚的异常类型。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
